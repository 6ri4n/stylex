---
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Merging styles

As seen previously, you can use the `stylex` function to convert a style object
to a className string that can be used directly in your markup. However,
`stylex` function is more powerful than that and can be used to merge multiple
styles deterministically and based on the usage order.

Consider that a couple of style objects are defined as so:

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  base: {
    fontSize: 16,
    lineHeight: 1.5,
    color: 'rgb(60,60,60)',
  },
  highlighted: {
    color: 'rebeccapurple',
  },
});
```

You can use the result of merging both style objects like so:

```tsx
<div className={stylex(styles.base, styles.highlighted)} />
// OR
<div {...stylex.spread([styles.base, styles.highlighted])} />
```

:::info

A simple way to think about the `stylex` function is that it does what
`Object.assign` does. It merges many objects and the later objects have
precedence over previous objects.

A simple implementation of the `stylex` function could be:

```tsx
const stylex = (...styles) => {
  // Take care of nested Arrays
  const flatArrayOfStyles = styles.flat();
  // Merge the objects
  const resolvedStyleObject = Object.assign({}, ...flatArrayOfStyles);
  // Pluck classNames:
  const className = Object.values(resolvedStyleObject).join(' ');
  return className;
};
```

The actual implementation is optimized for performance.

The `stylex.spread` function similarly, but it returns an object conataining
`className` string and a `style` object.

:::

Here, it is important to note that the last argument to the `stylex` function
will always win. The order in which the styles are defined does not matter, only
the order in which they are passed to the `stylex` function. In the example
above, the resolved `color` of the div will be "rebeccapurple" simply becomes
`styles.highlighted` comes after `styles.base` in the argument list of the
`stylex` function.

## Conditional styles

The `stylex` function can also ignore falsy values such as `null`, `undefined`
or `false`. This ability can be used when you need to apply some styles
conditionally.

```tsx
<div
  className={stylex(
    styles.base,
    props.isHighlighted && styles.highlighted,
    isActive ? styles.active : styles.inactive,
  )}
/>
```

:::info

It is recommended that you inline the logic to apply your styles directly with
the `stylex()` call for readability.

:::

When using styles conditionally, you can use ternary expressions, or the `&&`
operator. Remember that any pattern that would work while merging objects with
`Object.assign`, should work here too.

### Variants

A common pattern offerred by various other styling solutions is often called
"variants". In this pattern you apply one of a list of possible styles based on
the value of the prop named `variant`.

The existing patterns presented so far can be used to implement variants.

First to define your variant styles, you can define a set of style with
`Style Names` that match your variant names.

```tsx
import stylex from '@stylexjs/stylex';

// Base Styles:
const styles = stylex.create({
  base: {
    /* ...base styles here... */
  },
});

const colorVariants = stylex.create({
  violet: {
    backgroundColor: {
      default: 'blueviolet',
      ':hover': 'darkviolet',
    },
    color: 'white',
  },
  gray: {
    backgroundColor: {
      default: 'gainsboro',
      ':hover': 'lightgray',
    },
  },
});
```

And then you apply the styles by using your variant prop as a key on the
`colorVariants` object.

<Tabs>
  <TabItem value="stylex" label="stylex" default>

```tsx
function Button({color, ...props}) {
  return (
    <button {...props} className={stylex(styles.base, colorVariants[color])} />
  );
}
```

  </TabItem>
  <TabItem value="spread" label="stylex.spread">

```tsx
function Button({color, ...props}) {
  return (
    <button {...props} {...stylex.spread(styles.base, colorVariants[color])} />
  );
}
```

  </TabItem>
</Tabs>
