---
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Merging styles

As seen previously, you can use the `stylex` function to convert a style object
to a className string that can be used directly in your markup. However,
`stylex` function is more powerful than that and can be used to merge multiple
styles deterministically and based on the usage order.

Consider that a couple of style objects are defined as so:

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  base: {
    fontSize: 16,
    lineHeight: 1.5,
    color: 'rgb(60,60,60)',
  },
  highlighted: {
    color: 'rebeccapurple',
  },
});
```

You can use the result of merging both style objects like so:

```tsx
<div {...stylex.spread([styles.base, styles.highlighted])} />

// Legacy API
<div className={stylex(styles.base, styles.highlighted)} />
```

:::info

A simple way to think about the `stylex` function is that it does what
`Object.assign` does. It merges many objects and the later objects have
precedence over previous objects.

A simple implementation of the `stylex` function could be:

```tsx
const stylex = (...styles) => {
  // Take care of nested Arrays
  const flatArrayOfStyles = styles.flat();
  // Merge the objects
  const resolvedStyleObject = Object.assign({}, ...flatArrayOfStyles);
  // Pluck classNames:
  const className = Object.values(resolvedStyleObject).join(' ');
  return className;
};
```

The actual implementation is optimized for performance.

The `stylex.spread` function similarly, but it returns an object conataining
`className` string and a `style` object.

:::

Here, it is important to note that the last styles in the list of styles passed
to the `stylex.spread` function will always win. Styles are always resolved by
_application order_.

When in doubt, think about `Object.assign` or inline styles in HTML. The last
styles applied always wins.

## Conditional styles

The `stylex` function can also ignore falsy values such as `null`, `undefined`
or `false`. This ability can be used when you need to apply some styles
conditionally.

```tsx
<div
  {...stylex.spread([
    styles.base,
    props.isHighlighted && styles.highlighted,
    isActive ? styles.active : styles.inactive,
  ])}
/>
```

:::info

It is recommended that you inline the conditional logic to apply your styles
directly with the `stylex.spread()` calls for readability.

:::

When using styles conditionally, you can use ternary expressions, or the `&&`
operator. Remember that any pattern that would work while merging objects with
`Object.assign`, should work here too.

### Variants

A common styling pattern called "variants" lets you apply one of a list of
possible styles based on the value of the prop named `variant`.

StyleX supports this pattern no additional API.

First to define your variant styles, you can define a set of style with
`Style Names` that match your variant names.

```tsx
import stylex from '@stylexjs/stylex';

// Base Styles:
const styles = stylex.create({
  base: {
    /* ...base styles here... */
  },
});

const colorVariants = stylex.create({
  violet: {
    backgroundColor: {
      default: 'blueviolet',
      ':hover': 'darkviolet',
    },
    color: 'white',
  },
  gray: {
    backgroundColor: {
      default: 'gainsboro',
      ':hover': 'lightgray',
    },
  },
  // ... more variants here ...
});
```

And then you apply the styles by using your variant prop as a key on the
`colorVariants` object.

<Tabs>
  
  <TabItem value="spread" label="stylex.spread">

```tsx
function Button({color, ...props}) {
  return (
    <button
      {...props}
      {...stylex.spread([styles.base, colorVariants[color]])}
    />
  );
}
```

  </TabItem>
  <TabItem value="stylex" label="stylex (legacy)" default>

```tsx
function Button({color, ...props}) {
  return (
    <button {...props} className={stylex(styles.base, colorVariants[color])} />
  );
}
```

  </TabItem>
</Tabs>

As always, we try to not introduce any new concepts or APIs when existing object
patterns can be used.
