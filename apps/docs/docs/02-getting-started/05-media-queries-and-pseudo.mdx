---
sidebar_position: 5
---

# Media Queries And Pseudo Classes

StyleX uses a slightly different pattern than most other styling solutions when
it comes to Media Queries and Pseudo Selectors. Instead of writing your "base
styles", your "mobile styles" and your "hover styles", you write just one object
of styles. Within this object, your values can declaratively change based on
browser conditions.

This approach forces you to think holistically about your styles rather than
thinking about different states in isolation. It also makes style merging and
composition more predictable.

:::info

#### It's like Inline Styles.

Within Inline Styles, there are no Media Queries or Pseudo Classes. Instead
you're forced to use Javascript to conditionally change the Inline Styles you're
applying. StyleX just lets you define those "conditions" declaratively within
your style values themselves.

:::

## Pseudo Classes

Pseudo Classes can be nested within style definitions, similar to how they work
tools such Sass and other CSS-in-JS libraries.

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  button: {
    color: {
      default: 'blue',
      ':hover': 'scale(1.1)',
      ':active': 'scale(0.9)',
    },
  },
});
```

And you can use the styles as usual:

```tsx
<button {...stylex.spread([styles.button])} />
```

## Media Queries (and other `@` Rules)

Media Queries can, similarly, be nested within style definitions.

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  base: {
    width: {
      default: 800,
      '@media (max-width: 800px)': '100%',
    },
  },
});
```

Using styles remains the same

```tsx
<div {...stylex.spread([styles.base])} />
```

<details>
<summary>Container Queries</summary>

Container Queries can be used the same way as Media Queries. The same is true
for `@supports` and other similar At Rules.

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  base: {
    width: {
      default: 800,
      '@container (max-width: 800px)': '100%',
    },
  },
});
```

For _named_ container queries, we are looking into an API that will help you
avoid using "magic strings" and be able to use references for such names
instead.

</details>

## Combining Conditions

Your Style Values can be be nested more than one level deep when you need to
combine Media Queries and Pseudo Selectors

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  button: {
    color: {
      default: 'var(--blue-link)',
      ':hover': {
        default: null,
        '@media (hover: hover)': 'scale(1.1)',
      },
      ':active': 'scale(0.9)',
    },
  },
});
```

:::info

The `default` case is required when authoring conditional styles. If you don't
want any style to be applied in the default case, you can use `null` as the
value.

Using `null` for a (non-`default`) condition has no effect and should be
considered invalid.

:::

## Pseudo Elements

:::note

Avoid Pseudo Elements when possible and use actual HTML elements instead. e.g.
`::before` and `::after`, can be replaced with simple `div` or `span` child
elements.

:::

Other than Pseudo Classes (which start with a single `:`) and At Rules (which
start with `@`) CSS also contains "Pseudo Elements". Pseudo Elements are
different from Pseudo Classes as they start with `::`. Some common examples of
Pseudo Elements are:

- `::placeholder`
- `::backdrop`
- `::selection`

Pseudo Elements are very different from Pseudo Classes (despite the similar
name) because they do not represent some kind of state. Instead, they are CSS's
way to target a completely different DOM element, that doesn't actually exist in
the HTML itself.

Therefore, in the cases where you need to target Pseudo Elements, you define
those styles in a top-level condition separate from the styles for the HTML
element itself.

```tsx
const styles = stylex.create({
  input: {
    color: {
      default: '#333',
      ':invalid': 'red',
    },
    '::placeholder': {
      color: '#999',
    },
  },
});
```
