---
sidebar_position: 4
---

# Composing styles across modules

When you define styles, you don’t have to use those styles in the same module.
You can also pass them like any other value across modules as props to a custom
component.

## Passing Styles to a custom component

```tsx
<CustomComponent xstyle={styles.base} />
```

:::warning

Don't use the `stylex.spread` or `stylex` functions when passing styles to a
custom component.

### Don't Do This!

```tsx
// NO!
<CustomComponent xstyle={stylex(styles.base)} />
// NO!
<CustomComponent xstyle={stylex.spread([styles.base])} />
```

The `stylex.spread` function should only be used directly on an HTML element.
Here, we used a prop named `xstyle` on a custom component named
`CustomComponent`.

:::

Conditional styles just you would when setting styles on an HTML element. The
only difference is that instead of using the `stylex.spread` function, we use an
Array literal instead:

```tsx
<CustomComponent xstyle={[styles.base, styles.highlighted]} />;

<CustomComponent
  xstyle={[styles.base, props.isHighlighted && styles.highlighted]}
/>;
```

:::info

The prop name `xstyle` is an arbitrary name. You can choose your own prop names
for your codebase.

We chose the name `xstyle` as short for “external styles”.

:::

## Accepting StyleX Styles as Props

Accepting custom `StyleX Styles` is as simple as accepting any other prop.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="spread" label="stylex.spread">

```tsx
import stylex from '@stylexjs/runtime';

// Local Styles
const styles = stylex.create({
  base: {
    /*...*/
  },
});

function CustomComponent({xstyle}) {
  return <div {...stylex.spread([styles.base, xstyle])} />;
}
```

  </TabItem>
  <TabItem value="stylex" label="stylex (legacy)" default>

```tsx
import stylex from '@stylexjs/runtime';

// Local Styles
const styles = stylex.create({
  base: {
    /*...*/
  },
});

function CustomComponent({xstyle}) {
  return <div className={stylex(styles.base, xstyle)} />;
}
```

  </TabItem>
</Tabs>

The `xstyle` prop which is passed from another component (example above) may
either be a single object or an Array of multiple objects. Luckily, the
`stylex.spread` function can handle nested Arrays of style objects and the code
above will _just work_.

In the code example above, the external styles in the `xstyle` prop is passed
last to the `stylex.spread` function. This means that any external styles will
override and win over any local styles defined in `styles.foo`. While this is
not a requirement of styles, we recommend that you follow this pattern for your
own custom components so that you can have predictable behavior when passing
styles to custom component.

There may be cases when you don't want to allow overriding certain local styles
in your custom component. In such cases, we recommend that you limit the styles
that can be passed into your component with Prop Types.

Not only can you accept StyleX style objects as props, the styles are also fully
type-safe as you can add type annotations (in Typescript or Flow) to define
exactly the styles you accept.

:::info

If you're not using Typescript (or Flow) in your codebase, you can pass styles
that should not be override-able after `xstyle` to the `stylex()` or
`stylex.spread()` function call.

<Tabs>
  <TabItem value="spread" label="stylex.spread">

```tsx
import stylex from '@stylexjs/runtime';

// Local Styles
const styles = stylex.create({
  /*...*/
});

function CustomComponent({xstyle}) {
  return <div {...stylex.spread(styles.base, xstyle, styles.essential)} />;
}
```

  </TabItem>
  <TabItem value="stylex" label="stylex" default>

```tsx
import stylex from '@stylexjs/runtime';

// Local Styles
const styles = stylex.create({
  /*...*/
});

function CustomComponent({xstyle}) {
  return <div className={stylex(styles.base, xstyle, styles.essential)} />;
}
```

  </TabItem>
</Tabs>

:::

## “Unsetting” styles

Sometimes, instead of passing in your own override styles, you simply want to
remove styles that have already been applied by a component. CSS gives you a few
values to do so such as `initial`, `inherit`, `unset`, and `revert`.

You can use these values in StyleX too, but they result in their own atomic
className that is usually redundant. Instead, if you just want to remove StyleX
styles for a particular property you can set it's value to `null`.

Here is an example to remove the `color` style from a component:

```tsx
const styles = stylex.create({
  base: {
    color: null,
  },
});
```

`styles.base` would behave the same as if `color: inherit` was used in CSS, but
there will be no className for the `color` property applied at all.
