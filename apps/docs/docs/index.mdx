---
sidebar_position: 1
---

# Welcome to Stylex

StyleX is a simple and easy to use CSS-in-JS library that gives you the developer experience of using inline styles in Javascript combined with the performance of static atomic styles.

## Stylex in 5 minutes

Using StyleX will feel very familiar if you have any experience with React Native. You simply define your styles and use them.

#### Define Styles

```tsx
import stylex from '@stylexjs/stylex';

// Define styles
const styles = stylex.create({
  // base styles
  main: {
    width: '100%',
    maxWidth: 800,
    minHeight: 40,
  },
  // conditional styles
  active: {
    transform: 'scale(0.9)',
  },
});
```

#### Use Styles on an HTML element

```tsx
// Use styles
<div
  className={stylex(
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as a prop
    props.xstyle,
  )}
/>
```

#### Passing Styles to a custom component.

```tsx
<CustomComponent
  xstyle={[
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as a prop
    props.xstyle,
  ]}
/>
```

Although the example above uses JSX, StyleX itself is framework agnostic and can be used be used with any UI framework that lets you write your javascript and HTML markup in the same JS file.

## Features

### Expressive

- Easy-to-use API that is as simple as Inline styles
- Apply styles conditionally
- Merge and compose styles arbitrarily across multiple modules
- Use Media Queries and Pseudo Classes without worrying about CSS specificity.

### Predictable

- "The last style always wins!" - StyleX will always give you predictable results
  - No need to worry about using CSS shorthands vs specific styles
  - No need to think about specificity of Media Queries or Pseudo Classes

### Fast

- Uses Atomic Styles to generate the minimum set of rules possible.
  - The speed of Tailwind, the ease of use and power of inline styles!
- All CSS is generated at compile time into a single bundle
  - No runtime style injection
  - No style recalculation to due to repeated CSS files loading

## Design principles

### Optimized for large apps

StyleX uses Atomic Styles. This means that there is a single style for className. This maximizes reusability of styles among your components. This enables stylex to create a single CSS bundle that can be loaded upfront for your entire application. This means that loading new routes won't fetch additional styles which causes style recalculation and layout thrashing.

By creating a single bundle of atomic styles, you get performance that scales well for larger applications, but might be marginally slower for small applications. StyleX chooses to focus on applications where performance is more likely to be a problem rather than try to optimize for applications where any solution is going to be "fast enough".

### Choosing Consistency over the raw expressiveness of CSS.

StyleX, unlike most other styling solutions on the web, lets you expressively compose styles and pass them around among components. This opens up a whole new world of possibilities for design systems and components where you can accept styles as props and trust them to work predictably.

To enable this kind of predictable expressiveness, StyleX will sometimes limit the kind of styles that you can author. StyleX does not allow complex selectors and certain CSS properties may be supported at all.

### Statically Typed

All StyleX styles are strong typed. You can use Typescript (or Flow) to add type constraints for styles that a component accepts. Again, using StyleX should feel no different than using Inline Styles directly!

### Co-location

StyleX is betting that writing your styles in the same javascript as your component is a superior experience to writing styles in separate files. This bet can sometimes limit the kinds of features that can be implemented or make implementations of other features more challenging. We believe that the improved Developer Experience that comes from Style co-location is worth that extra effort.

### Minimal Magic

While StyleX uses a compiler to statically extract CSS and optimize performance, there is a `dev-runtime` package available that does everything at runtime. StyleX tries to only create abstractions that are easy to understand and don't hide how everything works too much.

### Pit of Success

We want StyleX to create a "Pit of Success" by giving you one, and only one, good way to do things well. We aim to have an API that makes the simple things easy and performant and the edge-cases possible.

## Comparison with other tools

:::warning

The data in table may be wrong, outdated or both. This is a work in progress and we will fill it with valid data over time. Please don't take this table as a judgement of other CSS-in-JS solutions.

:::

<table>
  <thead>
    <tr>
      <th>Package</th>
      <th>Static Extraction</th>
      <th>Atomic Styles</th>
      <th>Object Literals</th>
      <th>Styles Colocation</th>
      <th>Media Queries</th>
      <th>Pseudo Classes</th>
      <th>Conditional Styles</th>
      <th>Style Composition</th>
      <th>Dynamic Styles</th>
      <th>Strongly Typed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>StyleX</strong>
      </td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Soon</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>
        <strong>Emotion</strong>
      </td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td>
        <strong>Linaria</strong>
      </td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>
        <strong>Vanilla Extract</strong>
      </td>
      <td>Yes</td>
      <td>Opt-in</td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Opt-in</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>
        <strong>Stitches</strong>
      </td>
      <td>Yes</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>With Variants</td>
      <td>No</td>
      <td>No</td>
      <td>No</td>
    </tr>
  </tbody>
</table>

## Bugs and Missing Features

StyleX is _not_ complete. Here is an (incomplete) list of things that still need to be done.

- [ ] CSS Grid Layout is not supported yet. (Some additional properties may also give you lint errors)
- [ ] Not all CSS shorthands are supported and properly disallowed. (This can lead to unpredictable behavior when composing styles)
- [ ] The ESLint plugin does not catch all invalid values and is a weak replacement for stylelint. Lots of improvements are coming over time.
- [ ] There is no ESLint plugin to catch unused styles yet. Coming soon.
- [ ] There is no official way to use unsupported styles yet. `UNSUPPORTED_PROPERTY(...)` function is coming soon.
- [ ] There is no official implementation for React Native yet. Coming soon.
- [ ] There is no first-class API for theming. For now, you can define your themes in a CSS file by declaring CSS variables and then using those variables in your stylex styles.
