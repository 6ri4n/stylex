---
sidebar_position: 1
---

# Welcome to Stylex

StyleX is a simple and easy to use CSS-in-JS library that gives you the
developer experience of using inline styles in Javascript combined with the
performance of static atomic styles.

## Stylex in 5 minutes

Using StyleX should feel no different than using Inline Styles directly. You
define your styles and use them. That's it!

#### Define Styles

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  // base styles
  main: {
    width: '100%',
    maxWidth: 800,
    minHeight: 40,
  },
  // conditional styles
  active: {
    transform: 'scale(0.9)',
  },
});
```

#### Use Styles on an HTML element

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({ ... });
// Use styles
<div
  className={stylex(
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as a prop
    props.xstyle,
  )}
/>;
```

The example above uses JSX, StyleX itself is framework agnostic. For example,
here is how you would use StyleX with an `html` template literal in Lit HTML:

```tsx
return html`<div
  class=${stylex(
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as a prop
    props.xstyle,
  )} />`;
```

While the API is expressive all styles are compiled into atomic classNames and
bundled into a single CSS file. This means that you get the ease of use and
expressiveness of Inline Styles without sacrificing performance.

## Features At a glance

### Expressive

- Easy-to-use API that is as simple as Inline styles
- Apply styles conditionally
- Merge and compose arbitrary styles across component and file boundaries.
- Use local constants and expressions to keep your styles DRY
- Or repeat yourself without worrying about performance
- Ability to use dynamic styles when you really need them with minimal overhead.
- Expressive and simple API for theming with CSS variables

### Predictable

- "The last style always wins!" - StyleX will always give you predictable
  results
  - No need to worry about using CSS shorthands vs specific styles
  - No need to think about specificity of Media Queries or Pseudo Classes
- Style Encapsulation - All styles are caused by classNames set on an elemnt
  directly.
  - Complex selectors never "style at a distance"

### Fast

- Uses Atomic Styles to generate the minimum set of rules possible.
- All CSS is generated at compile time into a single bundle
  - No runtime style injection
  - No style recalculation to due repeated lazy loading of styles at runtime

## Design principles

### Choosing Consistency over the raw expressiveness of CSS.

StyleX, unlike most other styling solutions on the web, lets you expressively
compose styles and pass them around among components. This opens up a whole new
world of possibilities for design systems and components where you can accept
styles as props and trust them to work predictably.

To enable this kind of predictable expressiveness, StyleX will sometimes limit
the kind of styles that you can author. StyleX does not allow complex selectors
and certain CSS properties may be supported at all.

### Statically Typed

All StyleX styles are strong typed. You can use Typescript (or Flow) to add type
constraints for styles that a component accepts. Again, using StyleX should feel
no different than using Inline Styles directly!

### Co-location

StyleX is betting that writing your styles in the same javascript as your
component is a superior experience to writing styles in separate files. This bet
can sometimes limit the kinds of features that can be implemented or make
implementations of other features more challenging. We believe that the improved
Developer Experience that comes from Style co-location is worth that extra
effort.

### Minimal Magic

While StyleX uses a compiler to statically extract CSS and optimize performance,
there is a `dev-runtime` package available that does everything at runtime.
StyleX tries to only create abstractions that are easy to understand and don't
hide how everything works too much.

### Pit of Success

We want StyleX to create a "Pit of Success" by giving you one, and only one,
good way to do things well. We aim to have an API that makes the simple things
easy and performant and the edge-cases possible.

## Comparison with other tools

:::warning

The data in table may be wrong, outdated or both. This is a work in progress and
we will fill it with valid data over time. Please don't take this table as a
judgement of other CSS-in-JS solutions.

:::

| Package           | Static | Atomic | Style Format | Colocation | Composition | Dynamic Styles | Types |
| ----------------- | ------ | ------ | ------------ | ---------- | ----------- | -------------- | ----- |
| StyleX            | ✅     | ✅     | Objects      | ✅         | ✅          | ✅             | ✅    |
| Tailwind          | ✅     | ✅     | Class Names  | ✅         | ❌          | ❌             | ❌    |
| Emotion           | ❌     | ❌     | Strings      | ✅         | ❌          | ❌             | ❌    |
| Styled Components | ❌     | ❌     | Strings      | ✅         | ❌          | ❌             | ❌    |
| Linaria           | ✅     | ❌     | Strings      | ✅         | ❌          | ✅             | ❌    |
| Vanilla Extract   | ✅     | Opt-in | Either       | ❌         | Opt-in      | Opt-in         | ✅    |
| Stitches          | ❌     | ❌     | Objects      | ✅         | ❌          | ❌             | ❌    |
| Styletron         | ❌     | ✅     | Object       | ✅         | ❌          | ✅             | ❌    |

## Roadmap

StyleX is _not_ complete. Here is an (incomplete) list of things that still need
to be done.

- The ESLint plugin does not catch all invalid values and is a weak replacement
  for stylelint. Lots of improvements are coming over time.
- There is no ESLint plugin to catch unused styles yet. Coming soon.
- Complex selectors involving descendant selectors, sibling selectors, etc. are
  not supported yet.
- The API for theming with CSS variables is unstable and may change.
- Official plugin for various meta-frameworks like NextJS, Nuxt, SvelteKit,
  Vite, etc. are either unstable or non-existent for now.
