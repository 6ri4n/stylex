---
sidebar_position: 1
---

# Welcome to Stylex

StyleX is a simple and easy to use CSS-in-JS library that gives you the
developer experience of using inline styles in Javascript combined with the
performance of statically generated atomic styles.

## Stylex in 5 minutes

Using StyleX should feel no different from using Inline Styles directly. You
define your styles and use them; that's it!

#### Define Styles

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  // base styles
  main: {
    width: '100%',
    maxWidth: 800,
    minHeight: 40,
  },
  // conditional styles
  active: {
    transform: 'scale(0.9)',
  },
});
```

#### Use Styles on an HTML element

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({ ... });
// Use styles
<div
  className={stylex(
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as props
    props.xstyle,
  )}
/>;
```

The example above uses JSX, StyleX itself is framework agnostic. For example,
here is how you would use StyleX with an `html` template literal in Lit HTML:

```tsx
return html`<div
  class=${stylex(
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as props
    props.xstyle,
  )} />`;
```

While the API is expressive all styles are compiled into atomic classNames and
bundled into a single CSS file. This means that you get the ease of use and
expressiveness of Inline Styles without sacrificing performance.

## Features At a glance

### Expressive

- Easy-to-use API that is as simple as Inline styles
- Apply styles conditionally
- Merge and compose arbitrary styles across component and file boundaries.
- Use local constants and expressions to keep your styles DRY
- Or repeat yourself without worrying about performance
- Ability to use dynamic styles when needed with minimal overhead.
- An expressive and simple API for theming with CSS variables

### Predictable

- "The last style applied always wins!" - StyleX will always give you
  predictable results
  - No need to worry about using CSS shorthands vs specific styles
  - No need to think about specificity of Media Queries or Pseudo Classes
- Style Encapsulation - All styles are caused by classNames applied directly set
  on an element
  - Complex selectors never "style at a distance"

### Fast

- Uses Atomic Styles to generate the minimum set of rules possible.
- All CSS is generated at compile time into a single bundle
  - No runtime style injection
  - No style recalculation due to repeated lazy loading of styles at runtime

## Comparison with other tools

:::warning

The data in table may be wrong, outdated or both. This is a work in progress and
we will fill it with valid data over time. Please don't take this as a judgement
of other styling solutions.

:::

export const LinariaLink = () => (
  <a
    href="https://github.com/callstack/linaria/blob/master/docs/ATOMIC_CSS.md"
    target="_blank">
    Opt-in
  </a>
);

export const SprinklesLink = () => (
  <a
    href="https://vanilla-extract.style/documentation/packages/sprinkles/"
    target="_blank">
    Opt-in
  </a>
);

| Package           | Static | Atomic            | Style Format    | Colocation | Composition       | Dynamic Styles    | Typed |
| ----------------- | ------ | ----------------- | --------------- | ---------- | ----------------- | ----------------- | ----- |
| StyleX            | ✅     | ✅                | Objects         | ✅         | ✅                | ✅                | ✅    |
| Tailwind          | ✅     | ✅                | Classes         | ✅\*       | ❌                | ❌                | ❌    |
| PandaCSS          | ✅     | ✅                | Classes/Objects | ✅         | ✅                | ❔                | ❔    |
| Tamagui           | ✅     | ✅                | Objects/Props   | ✅         | ✅                | ❔                | ❔    |
| Vanilla Extract   | ✅     | <SprinklesLink /> | Either          | ❌         | <SprinklesLink /> | <SprinklesLink /> | ✅    |
| CSS Modules       | ✅     | ❌                | CSS Files       | ❌         | ❌                | ❌                | ❌    |
| Linaria           | ✅     | <LinariaLink />   | Strings         | ✅         | ❌                | ✅                | ❌    |
| Emotion           | ❌     | ❌                | Strings         | ✅         | ❌                | ❌                | ❌    |
| Styled Components | ❌     | ❌                | Strings         | ✅         | ❌                | ❌                | ❌    |
| Stitches          | ❌     | ❌                | Objects         | ✅         | ❌                | ❌                | ❌    |
| Styletron         | ❌     | ✅                | Object          | ✅         | ❌                | ✅                | ❌    |

`*` - Tailwind doesn't co-locate the styles themselves, but since it uses a
special shorthand to represent styles, it is effectively the same.

<details>
<summary>
Glossary
</summary>

- **Static** - Does the library generate CSS at compile time?
- **Atomic** - Does the library generate atomic CSS?
- **Style Format** - What format are styles authored in? Strings, Objects, or
  separate CSS files.
- **Co-location** - Are the styles in the same file as your component?
- **Composition** - Can you compose and merge styles across component
  boundaries? Can you pass styles as props?
- **Dynamic Styles** - Can you generate styles with dynamic values not known
  until runtime?
- **Typed** - Are the authored styles typed? Can constrain what styles are
  passed to components with static types? This is only relevant when composing
  styles.

</details>

## Roadmap

StyleX is _not_ complete. Here is an (incomplete) list of tasks that still need
to be completed.

- The ESLint plugin does not catch all invalid values and is a weak replacement
  for stylelint. Lots of improvements are coming soon.
- There is no ESLint plugin to catch unused styles yet. Coming soon.
- Complex selectors involving descendant selectors, sibling selectors, etc. are
  not supported yet.
- The API for theming with CSS variables is currently unstable and subject to
  change.
- Official plugin for various meta-frameworks like NextJS, Nuxt, SvelteKit,
  Vite, etc. are either unstable or non-existent for now.
