---
sidebar_position: 1
---

# Welcome to Stylex

StyleX is a simple and easy to use CSS-in-JS library that gives you the
developer experience of using inline styles in Javascript combined with the
performance of statically generated atomic styles.

## Stylex in 5 minutes

Using StyleX should feel no different from using Inline Styles directly. You
define your styles and use them; that's it!

#### Define Styles

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({
  // base styles
  main: {
    width: '100%',
    maxWidth: 800,
    minHeight: 40,
  },
  // conditional styles
  active: {
    transform: 'scale(0.9)',
  },
});
```

#### Use Styles on an HTML element

```tsx
import stylex from '@stylexjs/stylex';

const styles = stylex.create({ ... });
// Use styles
<div {...stylex.spread([
  // Use base styles
  styles.main,
  // Use styles if a condition is true
  isActive && styles.active,
  // Use styles passed in as props
  props.xstyle,
])} />;
```

The example above uses JSX, StyleX itself is framework agnostic. For example,
here is how you would use StyleX with an `html` template literal in Lit HTML:

```tsx
function litDiv(isActive, xstyle) {
  const {className, style} = stylex.spread([
    // Use base styles
    styles.main,
    // Use styles if a condition is true
    isActive && styles.active,
    // Use styles passed in as arguments
    xstyle,
  ]);

  return html`<div class=${className} style=${style} />`;
}
```

While the API is expressive all styles are compiled into atomic classNames and
bundled into a single CSS file. This means that you get the ease of use and
expressiveness of Inline Styles without sacrificing performance.

## Features At a glance

### Expressive

- Easy-to-use API that is as simple as Inline styles
- Apply styles conditionally
- Merge and compose arbitrary styles across component and file boundaries.
- Use local constants and expressions to keep your styles DRY
- Or repeat yourself without worrying about performance
- Ability to use dynamic styles when needed with minimal overhead.
- An expressive and simple API for theming with CSS variables

### Predictable

- "The last style applied always wins!" - StyleX will always give you
  predictable results
  - No need to worry about using CSS shorthands vs specific styles
  - No need to think about specificity of Media Queries or Pseudo Classes
- Style Encapsulation - All styles are caused by classNames applied directly set
  on an element
  - Complex selectors never "style at a distance"

### Fast

- Uses Atomic Styles to generate the minimum set of rules possible.
- All CSS is generated at compile time into a single bundle
  - No runtime style injection
  - No style recalculation due to repeated lazy loading of styles at runtime

## Roadmap

StyleX is _not_ complete. Here is an (incomplete) list of tasks that still need
to be completed.

- ESlint plugin improvements
  - The ESLint plugin does not catch all invalid values and is a weak
    replacement for stylelint. Lots of improvements are coming soon.
  - There is no ESLint plugin to catch unused styles yet. Coming soon.
- Complex selectors involving descendant selectors, sibling selectors, etc. are
  not supported yet.
- The API for theming with CSS variables is currently unstable and subject to
  change.
- There is no API to define `@font-face` rules yet. You can use plain CSS to do
  this for for now.
- There is no API to define `@counter-style` rules yet. You can use plain CSS to
  do this for now.
- Official plugin for various meta-frameworks like NextJS, Nuxt, SvelteKit,
  Vite, etc. are either unstable or non-existent for now.
