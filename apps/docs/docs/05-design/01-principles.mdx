---
sidebar_position: 1
---

# Core Principles

To understand why StyleX exists why it makes the decisions it does, it's
important to understand the core principles that guide it.

## Zero-cost Abstractions

When it comes to performance cost of StyleX, our guiding principle is that
StyleX should always be the fastest way to achieve a particular pattern. I.e.
Unless you opt into a feature, you should never pay for it with runtime
performance. We make the trade-off of doing more work at build-time to improve
runtime performance.

Here's how this plays out in practice:

### 1. Basic Styles authored and used in the same file

If you authors styles within a file and then consume all those styles in the
same file, the cost of StyleX is zero. This is because in addition to compiling
away your `stylex.create` calls, StyleX also compiles away your `stylex` calls
when possible.

So,

```tsx
import stylex from 'stylex';
const styles = stylex.create({
  red: {color: 'red'},
});
let a = stylex(styles.red);
```

Compiles down to just:

```tsx
let a = 'x1e2nbdu';
```

There is no runtime cost to this.

### 2. Using styles across files

When passing styles across file boundaries, you pay a small cost for the
additional power and expressivity. The `stylex.create` call is not deleted
entirely and instead leaves behind very simple object mapping keys to
classNames. And the `stylex()` or `stylex.spread()` calls are executed at
runtime.

This code, for example:

```tsx
const styles = stylex.create({
  foo: {
    color: 'red',
  },
  bar: {
    backgroundColor: 'blue',
  },
});

stylex(styles.foo, styles.bar, props.xstyle);
```

Compiles down to:

```tsx
const styles = {
  foo: {
    color: 'x1e2nbdu',
    $$css: true,
  },
  bar: {
    backgroundColor: 'x1t391ir',
    $$css: true,
  },
};

stylex(styles.foo, styles.bar, props.xstyle);
```

This definitely a little more code, but the runtime cost is still minimal
because how fast the `stylex()` and `stylex.spread()` functions are.

Most other styling solutions don't even let you compose styles across file
boundaries this way. The state of the art is to simply combine lists of
classNames.

## Styles should be deterministic and predictable

CSS is a powerful and extremely expressive language. However, it can sometimes
feel fragile. Some of this stems from a misunderstanding how CSS works, but a
lot of it stems from the discipline and organization required to keep your CSS
selectors with different specificities from stepping on each other's toes.

Most existing solutions to this problem rely on rules and conventions.

BEM and OOCSS introduce naming conventions such that we don't run into many of
these problems. But it puts the burden on the developer to follow the rules and
it mostly just tells you not to merge styles at all. This can lead to bloated
CSS.

Atomic utility classNames like Tailwind CSS and Tachyons relies on a convention
to ensure you don't apply conflicting classNames on the same element. This
limits you to a small subset of CSS's expressive power to make your styles
reliable.

StyleX aims to improve on both the consistency and predictability of styles
_and_ the expressive power available. We believe this is possible through
build-tools.

StyleX aims to give you a completely predictable and deterministic styling
system that works across files. And we aim to not only give you deterministic
results when merging multiple selectors, but also when merging multiple
shorthand and longhand properties. (`margin` vs `margin-top`).

"The last style applied always wins." is a core principle of StyleX.

## Readability & Maintainabity over Terseness

Many recent styling solutions are extremely terse and easy to write. Tailwind
CSS is popular and lets you author your styles by putting extremely terse
utility classNames directly on your markup. This is great for authoring styles
quickly, but in our opinion, in the long run it makes the styles harder to read
and maintain. It can also have a steeper learning curve up-front.

StyleX makes the choice to use the same CSS property names that you're already
used to. (We did decide to use camelCase instead of kebab-case as that makes
them easier to type in JavaScript.) This makes it easier to learn and read.

We also enforce that your styles are authored in objects separate from the HTML
elements where you use them. We made this decision to help with the readabiliy
of your HTML markup and so you can choose appropriate names for your styles to
indicate their purpose. `styles.active` tells you much more about the purpose of
a bunch of styles than what those styles are themselves.

This principle leads to trade-offs where authoring styles may take more typing
with StyleX than some other solutions, but your styles will be more readable and
maintainable in the long run.

## Small API Surface Area

At it's core StyleX can be boiled down to just two functions:

1. `stylex.create`
2. `stylex.spread`

You use `stylex.create` to create a bunch of styles and then you use
`stylex.spread` to apply those styles to an element.

Other than the fact that `stylex.create` takes static values, you don't really
need to learn anything else about how StyleX works. Things work the way you
expect when dealing with JavaScript objects and arrays. No surprises.

Other functions within the StyleX API should be simple utilities that feel
simple and obvious.

- `stylex.firstThatWorks` let's you define a series of fallback values for a
  property
- `stylex.keyframes` let's you define CSS keyframes for animations
- `stylex.createVars` let's you define CSS variables
- `stylex.varsProvider` let's you define a className to override the default
  values of CSS variables.

## Co-Location of Styles and Markup

There are benefits to making your code DRY, but we don't think that's true when
it comes to writing your styles.

The best and most readable way to write your styles is to write them in the same
file as the markup where you use them. Repeating yourself is not a bad thing
when it comes to styles.

StyleX enables you to write your styles in every file where you use them and
repeat yourself as many times as you want and it automatically de-duplicates all
the generated CSS to give you the smallest CSS bundle possible.

## Styles should be Type-Safe

Typescript has becomes massively popular due to the experience and safety it
provides. Our styles, however, have largly remained untyped and unreliable.
Except for some path-breaking projects such as
[Vanilla Extract](https://vanilla-extract.style/), styles are just bags of
strings in most styling solutions.

StyleX is authored in Flow with strong static types. It's packages on NPM come
with auto-generated types for both Flow and TypeScript. When there are
incompatibilies between the two type-systems we take the time to ensure that we
write custom Typescript types to achieve the same level of power and safety as
the original Flow.

_All styles are typed_. When accepting styles as props, you can use types to
constrain what you will and will not accept. Styles should be as type-safe as
any other props for your components.

## Framework-agnostic

StyleX is a CSS-in-JS solution, not a CSS-in-React solution. It's designed to be
used with any Javascript framework that lets you author your markup in your
Javacript. It can even be used with frameworks where you markup is stored in
separate templates, although that's not the ideal use-case.

React is probably the best fit for StyleX today, but we will make improvements
to make it work well with various different frameworks overtime.

## Style Encapsulation and Debuggability over Power

> All styles on an element should be caused by classNames on that element
> itself.

CSS makes it very easy to author styles in a way that let you cause "styles at a
distance":

- `.className > *`
- `.className ~ *`
- `.className:hover > div:first-child`

All of these patterns, while powerful, makes your styles fragile and harder to
debug. You apply classNames on one element and affect a completely different
element.

Styles such as `color` will still be inherited, but that is the _only_ form of
style-at-a-distance that StyleX allows. And in those cases too, the styles
applied directly on an element always take precedence over inherited styles.

This is often not the case when using complex selectors as the complex selectors
usually have higher specificity than the simple classname selectors used for
styles applied directly on the element.

StyleX disallows this entire class of selectors. This sometimes makes common
patterns in CSS impossible:

- e.g. It is currently impossible for a child element to have conditional styles
  when it's parent is hovered.

We will find ways to make these patterns possible in the future, without
breaking the core principle of style encapsulation.

## Styles should be modular and composable

NPM has made it extremely easy to share code across projects. However, sharing
CSS has remained a challenge.

When using third-party components, you have to either choose components with
styles baked in that are hard or impossible to customize, or "headless"
components that are completely unstyled.

The lack of a good system to predictably merge and compose styles across
packages has also been an obstacle when sharing styles within packages.

StyleX aims to create a system to easily and reliably share styles along with
components withiin packages on NPM.

## A single file is better than lots of lazily-loaded CSS

Most styling solutions lead to CSS that grows linearly with the size of your
codebase. For larger applications it makes loading all your CSS upfront
infeasible. So you end up splitting your CSS into multiple files and loading
them lazily as you need them.

This improves your initial load time and performance, but it comes at the cost
of slower updates as the browser needs to recalculate styles every time more CSS
is loaded.

With StyleX, we're aiming to create a system where the total amount of CSS is
small-enough that you can load all your CSS upfront without a significant
performance penalty.

The StyleX model doesn't make lazy-loading or critical-css impossible, but we
are not optimizing for it for now and are focusing on generating smallest,
fastest single CSS bundle possible.
