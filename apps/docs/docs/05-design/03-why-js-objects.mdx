---
sidebar_position: 3
---

# Why Objects Syntax for Styles?

When looking at the various CSS-in-JS (or similar) solutions that exist there
are two common patterns when it comes to the API:

### JS objects like we do in StyleX

```tsx
const styles = stylex.create({
  foo: {
    color: 'red',
    marginBlock: 0,
    overflow: 'auto',
  },
});
```

### Tagged Template strings that let you write normal CSS syntax in a string

```tsx
let styles = stylex.create`
  .foo {
    color: red;
    marginblock: 0px;
    overflow: auto;
  }
`;
```

We have often been asked why we don't support authoring CSS within template
strings to make the process easier.

A lot of thought has gone into the decision to not support template strings for
CSS. Here are some of the most important reasons:

## Loss of Types

The StyleX API is strongly typed. Every style you author has types too. This is
only really possible because we use Javascript objects to author `RawStyles`.

These types can then be leveraged to set contracts for the styles that your
component may or may not accept. You may make a component that only accepts
`color` and `backgroundColor` but no other styles.

```ts
type Props = {
  //...
  style?: StyleXStyle<{color?: string; backgroundColor?: string}>;
  //...
};
```

In another example, you may disallow margins while allowing any other styles:

```ts
type Props = {
  //...
  style?: StyleXStyleWithout<{
    margin: unknown;
    marginBlock: unknown;
    marginInline: unknown;
    marginTop: unknown;
    marginBottom: unknown;
    marginLeft: unknown;
    marginRight: unknown;
    marginBlockStart: unknown;
    marginBlockEnd: unknown;
    marginInlineStart: unknown;
    marginInlineEnd: unknown;
  }>;
  //...
};
```

Your styles being typed allows you to set up some extremely sophisticated rules
about the ways in which a component styles can be customized with **zero-runtime
cost**.

**Strings Don't have Types** Switching to CSS strings will mean we lose all type
information when you define styles. Working around this limitation would involve

## Incorrect Expectations

StyleX is not CSS pre-processor. It intentionally puts constraints on the power
of CSS selectors in order to give you a fast and predictable system.

Using a Javascript object as an API transparently nudges you into writing valid
styles as writing complex selectors _feel_ out of place.

An API that allowed template strings signals a kind of freedom where developers
would naturally start writing arbitrary CSS and expect it to _just work_. Such
expectations are incompatible with the way StyleX actually works. In order to
mitigate this issue, we would need to do aggressive validation within ESlint and
Babel.

This would lead to an unpleasant experience where API guides you in one
direction while the tooling gets noisy and tries to keep you within the bounds.

## Implementation Burden

This is the most trivial reason, but supporting template strings would also
increate the maintaince burden of StyleX.

- We would need to parse your strings and extract the authored styles
- We would need to create a code generation pipeline for type safety.
- We would need more complicated validation logic.
- We would need to map CSS syntax to StyleX concepts.

## Conclusion

Like all design decisions, there are tradeoffs when it comes to supporting
template strings for authoring styles, but in the larger context of StyleX, I
think the benefits of authoring styles as JS objects far outweight the
additional cost of typing the extra quotes while authoring styles.
