---
slug: rfc-media-pseudo-inversion
title: '[RFC] Media Queries and Pseudo Classes'
authors: nmn
tags: [hello, stylex, beta, npm]
---

import YouTube from '../components/YouTube.js';

[Link to Github Issue](https://github.com/facebookexternal/stylex/issues/137)

#### Video Explainer

<YouTube
  width="560"
  height="315"
  src="https://www.youtube.com/embed/N_Q77831__w"
  title="YouTube video player"
/>

In responsive design, users aren't really writing separate stylesheets for different viewport sizes (That's used to be called "adaptive design"). Rather, the process involves changing the value of _specific style properties_ based on viewport breakpoints.

As such, it might make more sense to make `@media` queries (and :pseudo classes) part of the style value.

Another way to think about this is that Media Queries and Pseudo Classes are simply conditions that the styles can depend on and not something separate from "regular" styles.

In regular CSS, whenever we use units such `vh` or `rem`, we are already using context from the browser itself to set a style. Media Queries and Pseudo Classes should be no different.

Instead of writing:

```js
const styles = stylex.create({
  foo: {
    position: 'absolute',
    '@media (max-width: 600px)': {
      position: 'sticky',
    },
  },
});
```

It might make more sense to write something on the lines of:

```js
const styles = stylex.create({
  foo: {
    position: {
      default: 'absolute',
      '@media (max-width: 600px)': 'sticky',
    },
  },
});
```

While there is small change when it comes to writing the style, the compiled object would be much simpler:

```js
// we can choose two generate more or more space-separated classNames
const styles = {
  foo: {
    position: 'pos-abs media-600-pos-sticky',
  },
};
```

Instead of:

```js
const styles = {
  foo: {
    position: 'pos-abs',
    '@media (max-width: 600px)__postion': 'media-600-pos-sticky',
  },
};
```

This solves the conflicts when combing styles as overriding the style for `position` would override _all_ position styles regardless of viewport size.

# What to do about Pseudo Selectors

When we start to consider that Media Queries are just "conditions" that affect the value of a style, we realise that the same is true of pseudo classes like `:hover`, `:focus` and `:active`.

And so part of this proposal would also involve moving pseudo selectors instead the value of individual style properties.

However, there are Pseudo _Elements_ such as `::selection`, `::scrollbar`, `::before`, `::placeholder` etc which refer to "hidden" elements rather than the element under a particular condition.

These selectors should remain outside the value of individual style properties.

# What to do about `@Supports` queries

`@Supports` will be treated just like `@Media` queries.

# A Fluent API that handles all kinds of conditions.

Using a custom function instead of strings would help make shimming these features on React Native easier.

This API would ensure that a `defaultValue` is always provided

```js
{
  position:
    stylex.defaultValue('absolute')
      .mediaWidth(0, 768, 'sticky')
      .mediaWidth(768, 1260, 'fixed'),
  opacity:
    stylex.defaultValue(0.5)
      .hover(0.75)
      .focus(0.85)
      .active(1),
}
```

This API can easily be extended for container queries in the near future: (A string can be accepted as the first argument for named containers. We can enforce that the names are generated by Stylex)

```js
{
  position:
    stylex.defaultValue('absolute')
      .containerWidth([0, 768], 'sticky')
      .containerWidth([768, 1260], 'fixed'),
  opacity:
    stylex.defaultValue(0.5)
      .containerWidth(containerName, [0, 768], 'sticky')
      .hover(0.75)
      .active(1),
}
```

This API can also enable more complex selectors without breaking style encapsulation:

```js
{
  position:
    stylex.defaultValue('absolute')
      .ancestorHasStyle({overflowY: 'scroll'}, 'sticky')
      .ancestorHasStyle({overflowY: 'auto'}, 'sticky'),
  opacity:
    stylex.defaultValue(0.5)
      .ancestorHover(ancestorID, 0.75)
      .hover(0.75)
      .active(1),
}
```

Here, by using the fact that StyleX used atomic styles, we can support [Style Queries](https://una.im/style-queries/) before CSS supports them.

## Benefits

### Better, more reliable composition of styles

Instead of looking at _every_ possible condition when a particular style may be set, you can confidently set `margin: 0` and trust your style override to work. It override the default margin value _and_ any `margin` that may be set within a media query or pseudo selectors.

### Co-location of all possible values for a style property

Even though this syntax is less familiar to CSS authors, it improves readability of styles as it becomes easy to see at a glance what style properties can change based on state and context.

All possible values for a particular style property also become easy to see in one place.

### Better Static Types

:::info

Although this would be easier to do with the Fluent API, this _is_ still possible with the plain object syntax.

:::

While it is easy to list every style property in a static object type, there is no way to list every possible Media and Supports query you may need. (This is actually possible in Typescript by using Template String types, but not in Flow). By moving Media Queries and Pseudo selectors _within_ style properties, we can have much better static types for the styles without having to resort to a long list of media queries that are used in the codebase.

By using the Fluent API described above, we can also improve the generated types of styles. Instead of generating separate object entries, we can give a union of all possible values as the type for a property.

We would get:

```tsx
// we can choose two generate more or more space-separated classNames
const styles: {
  foo: {
    position: StyleXClassNameFor<'position', 'absolute' | 'sticky'>;
  };
};
```

Instead of:

```tsx
const styles: {
  foo: {
    position: StyleXClassNameFor<'position', 'absolute'>;
    '@media (max-width: 600px)': {
      position: StyleXClassNameFor<'position', 'sticky'>;
    };
  };
};
```

The simpler union types for values helps you limit _what_ the value can be rather having to limit _when_ a value can be used. Usually when a component lets you customise its "width", it doesn't care if you want different widths for different breakpoints. However, it may have opinions on the possible values you can use to conform to the design system.

### Simpler React Native integration (Fluent API only)

By using a helper function rather objects with strings, we will no longer have to parse strings for implementing Media Queries in React Native as we'd have the numbers available directly.

### Standardised Media Queries (Fluent API only)

The actual Media Queries that are generated for the CSS can be an implementation detail of StyleX itself. This way we can remove the redundancy of some people using `max-width` queries and some people using `min-width` queries. StyleX's opinion on the "correct" implementation can also change without causing layouts to break.

### The ability to add more complex selectors without breaking the syntax

We can add more features that are based on more complex selectors without having to worry about specificity and other such issue.

## Tradeoffs

### Forced to write all conditions for a style in the same place

In some rare cases, components have special styles for certain breakpoints but want to allow customisation of the base styles. This will no longer be possible.
