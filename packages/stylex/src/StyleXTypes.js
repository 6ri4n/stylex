/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 */

'use strict';

import type { CSSProperties } from './StyleXCSSTypes';

// Using an opaque type to declare ClassNames generated by stylex.
export opaque type StyleXClassNameFor<+_K, +_V>: string = string;
export type StyleXClassNameForValue<+V> = StyleXClassNameFor<mixed, V>;
export type StyleXClassNameForKey<+K> = StyleXClassNameFor<K, mixed>;
export type StyleXClassName = StyleXClassNameFor<mixed, mixed>;

// Type for arbitrarily nested Array.
export type StyleXArray<+T> = T | $ReadOnlyArray<StyleXArray<T>>;

type CSSPropTypes = $ReadOnly<$ObjMap<CSSProperties, () => StyleXClassName>>;
export type NestedCSSPropTypes = $ReadOnly<{
  ...$Exact<CSSPropTypes>,
  // NOTE: the actual type should be nested objects.
  // fix after the types in stylex.js are fixed.
  ':active'?: StyleXClassName,
  ':focus'?: StyleXClassName,
  ':focus-visible'?: StyleXClassName,
  ':hover'?: StyleXClassName,
  ':disabled'?: StyleXClassName,
  ':empty'?: StyleXClassName,
  ':first-child'?: StyleXClassName,
  ':last-child'?: StyleXClassName,
  '::before'?: StyleXClassName,
  '::after'?: StyleXClassName,
  '::placeholder'?: StyleXClassName,
  '::-webkit-scrollbar'?: StyleXClassName,
  // Find a better way to do this. Being forced to add every media query.
  '@media (max-width: 564px)'?: StyleXClassName,
  '@media (min-height: 700px)'?: StyleXClassName,
  '@media (min-height: 700px) and (max-height: 789px)'?: StyleXClassName,
  '@media (min-height: 753px) and (max-height: 789px)'?: StyleXClassName,
  '@media (min-height: 790px)'?: StyleXClassName,
  '@media (max-width: 648px)'?: StyleXClassName,
  '@media (max-width: 899px)'?: StyleXClassName,
  '@media (max-width: 900px)'?: StyleXClassName,
  '@media (min-width: 900px)'?: StyleXClassName,
  '@media (min-width: 900px) and (max-width: 1259px)'?: StyleXClassName,
  '@media (max-width: 1099px)'?: StyleXClassName,
  '@media (max-width: 1199px)'?: StyleXClassName,
  '@media (max-width: 1259px)'?: StyleXClassName,
  '@media (min-width: 1290px)'?: StyleXClassName,
  '@media (max-width: 420px)'?: StyleXClassName,
  '@media (max-width: 500px)'?: StyleXClassName,
  '@media (pointer: coarse)'?: StyleXClassName,
  '@media (-webkit-min-device-pixel-ratio: 0)'?: StyleXClassName,
  '@media print'?: StyleXClassName,
  // Media queries used for Oculus Web Design Systems (OCDS components).
  '@media (max-width: 767px)'?: StyleXClassName,
  '@media (min-width: 768px)'?: StyleXClassName,
  '@media (min-width: 768px) and (max-width: 1024px)'?: StyleXClassName,
  '@media (max-width: 1024px)'?: StyleXClassName,
  '@media (min-width: 1025px)'?: StyleXClassName,
  '@media (min-width: 1025px) and (max-width: 1920px)'?: StyleXClassName,
  '@media (max-width: 1920px)'?: StyleXClassName,
  '@media (min-width: 1921px)'?: StyleXClassName,
  // Media queries used for Intern Data Products
  '@media (min-width: 1500px)'?: StyleXClassName,
  '@media (min-width: 1800px)'?: StyleXClassName,
  '@media (min-width: 2250px)'?: StyleXClassName,
  // webkit styles used for Search in Safari
  '::-webkit-search-decoration'?: StyleXClassName,
  '::-webkit-search-cancel-button'?: StyleXClassName,
  '::-webkit-search-results-button'?: StyleXClassName,
  '::-webkit-search-results-decoration'?: StyleXClassName,
  // Media queries used for the logged out header
  '@media (min-width: 950px)'?: StyleXClassName,
  // Media queries used for bizweb
  '@media (min-width: 1440px)'?: StyleXClassName,
  '@media (min-width: 1920px)'?: StyleXClassName,
  // Media queries used for fbai
  '@media (min-width: 800px)'?: StyleXClassName,
  // Media queries used for messengerkidsdotcom
  '@media (max-width: 1024px) and (min-width: 501px)'?: StyleXClassName,
}>;

export type StyleXSingleStyle = false | ?NestedCSSPropTypes;
export type XStyle<+T = NestedCSSPropTypes> = StyleXArray<false | ?T>;
export type XStyleWithout<+T: { [string]: void, ... }> = XStyle<
  $ReadOnly<$Rest<NestedCSSPropTypes, $Exact<T>>>,
>;

export type Keyframes = $ReadOnly<{ [name: string]: CSSProperties, ... }>;

export type LegacyTheme = $ReadOnly<{ [constantName: string]: string, ... }>;

// type CSSValue = string | number | $ReadOnlyArray<mixed>;
type MapCSSValueToClassName = <K, V>(K, V) => StyleXClassNameFor<K, V>;

export type MapNamespace<CSS: { ... }> = $ReadOnly<{
  ...$ObjMapi<CSS, MapCSSValueToClassName>,
  $$css: true,
}>;
// NOTE: Flow was confused by nested ObjMap so for now, nested styles
// are typed incorrectly to be a string. This won't matter for the time being.
// type MapStyleToClassName = (<Rule: {}>(
//   Rule,
// ) => $ObjMap<Rule, MapCSSValueToClassName>) &
//   MapCSSValueToClassName;
export type MapNamespaces = <CSS: { ... }>(CSS) => MapNamespace<CSS>;

export type Stylex$Create = <S: { ... }>(
  styles: S,
) => $ReadOnly<$ObjMap<S, MapNamespaces>>;

export type CompiledStyles = $ReadOnly<{
  $$css: true,
  [key: string]:
    | StyleXClassName
    | $ReadOnly<{ [key: string]: StyleXClassName, ... }>,
  ...
}>;

// This is the type for the variables object
export opaque type StyleXVarsTheme<+Vars: { +[string]: string }>: Vars = Vars;

export opaque type Theme<
  +Tokens: { +[string]: mixed },
  // eslint-disable-next-line no-unused-vars
  +ID: string = string,
>: $ReadOnly<{ [$Keys<Tokens>]: string }> = $ReadOnly<{
  [$Keys<Tokens>]: string,
}>;

export type TokensFromTheme<T: Theme<{ +[string]: mixed }>> = T extends Theme<
  infer Tokens,
>
  ? Tokens
  : empty;
type IDFromTheme<T: Theme<{ +[string]: mixed }>> = T extends Theme<
  { +[string]: mixed },
  infer ID,
>
  ? ID
  : empty;

export type FlattenTokens<
  T: {
    +[string]: string | { +default: string, +[string]: string },
  },
> = {
  +[Key in keyof T]: T[Key] extends { +default: infer X, +[string]: infer Y }
    ? X | Y
    : T[Key],
};

export type StyleX$CreateVars = <
  +DefaultTokens: {
    +[string]: string | { default: string, +[string]: string },
  },
  +ID: string = string,
>(
  tokens: DefaultTokens,
) => Theme<FlattenTokens<DefaultTokens>, ID>;

export type Variant<
  +T: Theme<{ +[string]: mixed }, string>,
  +_Tag: string = string,
> = $ReadOnly<{
  $$css: true,
  [string]: StyleXClassNameFor<string, IDFromTheme<T>>,
}>;

export type OverridesForTokenType<Config: { +[string]: mixed }> = {
  [Key in keyof Config]:
    | Config[Key]
    | { +default: Config[Key], +[string]: Config[Key] },
};

export type StyleX$OverrideVars = <
  +BaseTokens: Theme<{ +[string]: mixed }>,
  +ID: string = string,
>(
  baseTokens: BaseTokens,
  overrides: OverridesForTokenType<TokensFromTheme<BaseTokens>>,
) => Variant<BaseTokens, ID>;
