/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import type { CSSProperties } from './StyleXCSSTypes';

// Using an opaque type to declare ClassNames generated by stylex.
declare const StyleXClassNameTag: unique symbol;
export type StyleXClassNameFor<K, V> = string & {
  _opaque: typeof StyleXClassNameTag;
  key: K;
  value: V;
};

export type StyleXClassNameForValue<V> = StyleXClassNameFor<unknown, V>;
export type StyleXClassNameForKey<K> = StyleXClassNameFor<K, unknown>;
export type StyleXClassName = StyleXClassNameFor<unknown, unknown>;
// Type for arbitrarily nested Array.
export type StyleXArray<T> = T | ReadonlyArray<StyleXArray<T>>;

type lowerCaseAlphabet =
  | 'a'
  | 'b'
  | 'c'
  | 'd'
  | 'e'
  | 'f'
  | 'g'
  | 'h'
  | 'i'
  | 'j'
  | 'k'
  | 'l'
  | 'm'
  | 'n'
  | 'o'
  | 'p'
  | 'q'
  | 'r'
  | 's'
  | 't'
  | 'u'
  | 'v'
  | 'w'
  | 'x'
  | 'y'
  | 'z'
  | '-'
  | '_'
  | '@'
  | ':';

// Strings that don't start with a dollar sign.
// So that we can `&` with {$$css: true} without type errors.
type NonDollarStr = `${lowerCaseAlphabet}${string}`;

type CSSPropTypes = {
  [Key in keyof CSSProperties]: StyleXClassNameFor<Key, CSSProperties[Key]>;
};

export type NestedCSSPropTypes = CSSPropTypes &
  Readonly<{
    // NOTE: the actual type should be nested objects.
    // fix after the types in stylex.js are fixed.
    ':active': StyleXClassName;
    ':focus': StyleXClassName;
    ':focus-visible': StyleXClassName;
    ':hover': StyleXClassName;
    ':disabled': StyleXClassName;
    ':empty': StyleXClassName;
    ':first-child': StyleXClassName;
    ':last-child': StyleXClassName;
    '::before': StyleXClassName;
    '::after': StyleXClassName;
    '::placeholder': StyleXClassName;
    '::-webkit-scrollbar': StyleXClassName;

    [key: `@media (max-width: ${number}px)`]: StyleXClassName;
    [key: `@media (min-width: ${number}px)`]: StyleXClassName;
    [
      key: `@media (min-width: ${number}px) and (max-width: ${number}px)`
    ]: StyleXClassName;

    [key: `@media (max-height: ${number}px)`]: StyleXClassName;
    [key: `@media (min-height: ${number}px)`]: StyleXClassName;
    [
      key: `@media (min-height: ${number}px) and (max-height: ${number}px)`
    ]: StyleXClassName;

    [
      key: `@media (-webkit-min-device-pixel-ratio: ${number})`
    ]: StyleXClassName;
    '@media print': StyleXClassName;

    // webkit styles used for Search in Safari
    '::-webkit-search-decoration': StyleXClassName;
    '::-webkit-search-cancel-button': StyleXClassName;
    '::-webkit-search-results-button': StyleXClassName;
    '::-webkit-search-results-decoration': StyleXClassName;
  }>;

export type StyleXSingleStyle = false | (null | undefined | NestedCSSPropTypes);
export type XStyle<T = NestedCSSPropTypes> = StyleXArray<
  false | (null | undefined | T)
>;
export type XStyleWithout<T extends { [$$Key$$: NonDollarStr]: void }> = XStyle<
  Readonly<Pick<NestedCSSPropTypes, Exclude<keyof NestedCSSPropTypes, keyof T>>>
>;

export type Keyframes = Readonly<{ [name: NonDollarStr]: CSSProperties }>;
export type LegacyTheme = Readonly<{ [constantName: NonDollarStr]: string }>;

type RawStyles = {
  [key: NonDollarStr]:
    | null
    | string
    | number
    | Array<string | number>
    | RawStyles;
};

type CompiledNamespace<const N extends RawStyles> = {
  [K in keyof N]: N[K] extends string | number | null
    ? StyleXClassNameFor<K, N[K]>
    : N[K] extends ReadonlyArray<infer T>
    ? StyleXClassNameFor<K, T>
    : K extends `:${string}` | `@${string}`
    ? N[K] extends RawStyles
      ? CompiledNamespace<N[K]>
      : StyleXClassNameFor<K, N[K]>
    : N[K] extends { [key: string]: infer T }
    ? StyleXClassNameFor<K, T> // TODO: Handle nested objects
    : never;
};

export type Stylex$Create = <const S extends { [n: NonDollarStr]: RawStyles }>(
  styles: S,
) => Readonly<{
  [N in keyof S]: CompiledNamespace<S[N]> & { $$css: true };
}>;

export type CompiledStyles = Readonly<{
  [key: NonDollarStr]:
    | StyleXClassName
    | Readonly<{ [key: NonDollarStr]: StyleXClassName }>;
}> & { $$css: true };

type TTokens = {
  [key: NonDollarStr]: string | { default: string; [key: string]: string };
};

export type FlattenTokens<
  T extends {
    [key: NonDollarStr]: string | { default: string; [key: string]: string };
  },
> = {
  [Key in keyof T]: T[Key] extends { default: infer X } & {
    [key: Exclude<string, 'default'>]: infer Y;
  }
    ? X | Y
    : T[Key];
};

export type Theme<
  Tokens extends { [key: string]: unknown },
  ID extends symbol = symbol,
> = Readonly<{
  [_Key in Exclude<keyof Tokens, '_opaque' | '_tokens'>]: string;
}> & {
  _opaque: ID;
  _tokens: Tokens;
};

export type TokensFromTheme<T extends Theme<TTokens>> = T['_tokens'];

export type IDFromTheme<T extends Theme<TTokens>> = T['_opaque'];

export type StyleX$CreateVars = <
  DefaultTokens extends TTokens,
  ID extends symbol = symbol,
>(
  tokens: DefaultTokens,
) => Theme<FlattenTokens<DefaultTokens>, ID>;

export type Variant<
  T extends Theme<TTokens, symbol>,
  // eslint-disable-next-line no-unused-vars
  Tag extends symbol = symbol,
> = Readonly<{
  [Key: symbol]: StyleXClassNameFor<string, IDFromTheme<T>>;
}> & { _opaque: Tag };

type OverridesForTokenType<Config extends { [key: string]: unknown }> = {
  [Key in keyof Config]:
    | Config[Key]
    | { default: Config[Key]; [atRule: string]: Config[Key] };
};

export type StyleX$OverrideVars = <
  BaseTokens extends Theme<any>,
  ID extends symbol = symbol,
>(
  baseTokens: BaseTokens,
  overrides: OverridesForTokenType<TokensFromTheme<BaseTokens>>,
) => Variant<BaseTokens, ID>;
