/* eslint-disable flowtype/no-types-missing-file-annotation */
declare module '@babel/types' {
  // NOTE: This file is autogenerated. Do not modify.
  // See packages/babel-types/scripts/generators/ast-types.js for script used.

  declare interface BaseComment {
    +value: string;
    +start?: number;
    +end?: number;
    +loc?: SourceLocation;
    // generator will skip the comment if ignore is true
    +ignore?: boolean;
    +type: 'CommentBlock' | 'CommentLine';
  }

  declare export interface CommentBlock extends BaseComment {
    +type: 'CommentBlock';
  }

  declare export interface CommentLine extends BaseComment {
    +type: 'CommentLine';
  }

  declare export type Comment = CommentBlock | CommentLine;

  declare export interface SourceLocation {
    start: {
      line: number,
      column: number,
    };

    end: {
      line: number,
      column: number,
    };
  }

  declare interface BaseNode {
    +type: Node['type'];
    +leadingComments?: $ReadOnlyArray<Comment>;
    +innerComments?: $ReadOnlyArray<Comment>;
    +trailingComments?: $ReadOnlyArray<Comment>;
    +start?: number;
    +end?: number;
    +loc?: SourceLocation;
    +range?: [number, number];
    +extra?: { [string]: mixed };
  }

  declare export type CommentTypeShorthand = 'leading' | 'inner' | 'trailing';

  declare export type Node =
    | AnyTypeAnnotation
    | ArgumentPlaceholder
    | ArrayExpression
    | ArrayPattern
    | ArrayTypeAnnotation
    | ArrowFunctionExpression
    | AssignmentExpression
    | AssignmentPattern
    | AwaitExpression
    | BigIntLiteral
    | BinaryExpression
    | BindExpression
    | BlockStatement
    | BooleanLiteral
    | BooleanLiteralTypeAnnotation
    | BooleanTypeAnnotation
    | BreakStatement
    | CallExpression
    | CatchClause
    | ClassAccessorProperty
    | ClassBody
    | ClassDeclaration
    | ClassExpression
    | ClassImplements
    | ClassMethod
    | ClassPrivateMethod
    | ClassPrivateProperty
    | ClassProperty
    | ConditionalExpression
    | ContinueStatement
    | DebuggerStatement
    | DecimalLiteral
    | DeclareClass
    | DeclareExportAllDeclaration
    | DeclareExportDeclaration
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareOpaqueType
    | DeclareTypeAlias
    | DeclareVariable
    | DeclaredPredicate
    | Decorator
    | Directive
    | DirectiveLiteral
    | DoExpression
    | DoWhileStatement
    | EmptyStatement
    | EmptyTypeAnnotation
    | EnumBooleanBody
    | EnumBooleanMember
    | EnumDeclaration
    | EnumDefaultedMember
    | EnumNumberBody
    | EnumNumberMember
    | EnumStringBody
    | EnumStringMember
    | EnumSymbolBody
    | ExistsTypeAnnotation
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportDefaultSpecifier
    | ExportNamedDeclaration
    | ExportNamespaceSpecifier
    | ExportSpecifier
    | ExpressionStatement
    | File
    | ForInStatement
    | ForOfStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | Identifier
    | IfStatement
    | Import
    | ImportAttribute
    | ImportDeclaration
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | IndexedAccessType
    | InferredPredicate
    | InterfaceDeclaration
    | InterfaceExtends
    | InterfaceTypeAnnotation
    | InterpreterDirective
    | IntersectionTypeAnnotation
    | JSXAttribute
    | JSXClosingElement
    | JSXClosingFragment
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXFragment
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXOpeningFragment
    | JSXSpreadAttribute
    | JSXSpreadChild
    | JSXText
    | LabeledStatement
    | LogicalExpression
    | MemberExpression
    | MetaProperty
    | MixedTypeAnnotation
    | ModuleExpression
    | NewExpression
    | Noop
    | NullLiteral
    | NullLiteralTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteral
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | NumericLiteral
    | ObjectExpression
    | ObjectMethod
    | ObjectPattern
    | ObjectProperty
    | ObjectTypeAnnotation
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeInternalSlot
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | OptionalCallExpression
    | OptionalIndexedAccessType
    | OptionalMemberExpression
    | ParenthesizedExpression
    | PipelineBareFunction
    | PipelinePrimaryTopicReference
    | PipelineTopicExpression
    | Placeholder
    | PrivateName
    | Program
    | QualifiedTypeIdentifier
    | RecordExpression
    | RegExpLiteral
    | RegexLiteral
    | RestElement
    | RestProperty
    | ReturnStatement
    | SequenceExpression
    | SpreadElement
    | SpreadProperty
    | StaticBlock
    | StringLiteral
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | Super
    | SwitchCase
    | SwitchStatement
    | SymbolTypeAnnotation
    | TSAnyKeyword
    | TSArrayType
    | TSAsExpression
    | TSBigIntKeyword
    | TSBooleanKeyword
    | TSCallSignatureDeclaration
    | TSConditionalType
    | TSConstructSignatureDeclaration
    | TSConstructorType
    | TSDeclareFunction
    | TSDeclareMethod
    | TSEnumDeclaration
    | TSEnumMember
    | TSExportAssignment
    | TSExpressionWithTypeArguments
    | TSExternalModuleReference
    | TSFunctionType
    | TSImportEqualsDeclaration
    | TSImportType
    | TSIndexSignature
    | TSIndexedAccessType
    | TSInferType
    | TSInstantiationExpression
    | TSInterfaceBody
    | TSInterfaceDeclaration
    | TSIntersectionType
    | TSIntrinsicKeyword
    | TSLiteralType
    | TSMappedType
    | TSMethodSignature
    | TSModuleBlock
    | TSModuleDeclaration
    | TSNamedTupleMember
    | TSNamespaceExportDeclaration
    | TSNeverKeyword
    | TSNonNullExpression
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSOptionalType
    | TSParameterProperty
    | TSParenthesizedType
    | TSPropertySignature
    | TSQualifiedName
    | TSRestType
    | TSStringKeyword
    | TSSymbolKeyword
    | TSThisType
    | TSTupleType
    | TSTypeAliasDeclaration
    | TSTypeAnnotation
    | TSTypeAssertion
    | TSTypeLiteral
    | TSTypeOperator
    | TSTypeParameter
    | TSTypeParameterDeclaration
    | TSTypeParameterInstantiation
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeReference
    | TSUndefinedKeyword
    | TSUnionType
    | TSUnknownKeyword
    | TSVoidKeyword
    | TaggedTemplateExpression
    | TemplateElement
    | TemplateLiteral
    | ThisExpression
    | ThisTypeAnnotation
    | ThrowStatement
    | TopicReference
    | TryStatement
    | TupleExpression
    | TupleTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | TypeofTypeAnnotation
    | UnaryExpression
    | UnionTypeAnnotation
    | UpdateExpression
    | V8IntrinsicIdentifier
    | VariableDeclaration
    | VariableDeclarator
    | Variance
    | VoidTypeAnnotation
    | WhileStatement
    | WithStatement
    | YieldExpression;

  declare export interface ArrayExpression extends BaseNode {
    type: 'ArrayExpression';
    elements: Array<null | Expression | SpreadElement>;
  }

  declare export interface AssignmentExpression extends BaseNode {
    type: 'AssignmentExpression';
    operator: string;
    left: LVal;
    right: Expression;
  }

  declare export interface BinaryExpression extends BaseNode {
    type: 'BinaryExpression';
    operator:
      | '+'
      | '-'
      | '/'
      | '%'
      | '*'
      | '**'
      | '&'
      | '|'
      | '>>'
      | '>>>'
      | '<<'
      | '^'
      | '=='
      | '==='
      | '!='
      | '!=='
      | 'in'
      | 'instanceof'
      | '>'
      | '<'
      | '>='
      | '<='
      | '|>';
    left: Expression | PrivateName;
    right: Expression;
  }

  declare export interface InterpreterDirective extends BaseNode {
    type: 'InterpreterDirective';
    value: string;
  }

  declare export interface Directive extends BaseNode {
    type: 'Directive';
    value: DirectiveLiteral;
  }

  declare export interface DirectiveLiteral extends BaseNode {
    type: 'DirectiveLiteral';
    value: string;
  }

  declare export interface BlockStatement extends BaseNode {
    type: 'BlockStatement';
    body: Array<Statement>;
    directives: Array<Directive>;
  }

  declare export interface BreakStatement extends BaseNode {
    type: 'BreakStatement';
    label?: Identifier | null;
  }

  declare export interface CallExpression extends BaseNode {
    type: 'CallExpression';
    callee: Expression | V8IntrinsicIdentifier;
    arguments: Array<
      Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder
    >;
    optional?: true | false | null;
    typeArguments?: TypeParameterInstantiation | null;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface CatchClause extends BaseNode {
    type: 'CatchClause';
    param?: Identifier | ArrayPattern | ObjectPattern | null;
    body: BlockStatement;
  }

  declare export interface ConditionalExpression extends BaseNode {
    type: 'ConditionalExpression';
    test: Expression;
    consequent: Expression;
    alternate: Expression;
  }

  declare export interface ContinueStatement extends BaseNode {
    type: 'ContinueStatement';
    label?: Identifier | null;
  }

  declare export interface DebuggerStatement extends BaseNode {
    type: 'DebuggerStatement';
  }

  declare export interface DoWhileStatement extends BaseNode {
    type: 'DoWhileStatement';
    test: Expression;
    body: Statement;
  }

  declare export interface EmptyStatement extends BaseNode {
    type: 'EmptyStatement';
  }

  declare export interface ExpressionStatement extends BaseNode {
    type: 'ExpressionStatement';
    expression: Expression;
  }

  declare export interface File extends BaseNode {
    type: 'File';
    program: Program;
    comments?: Array<CommentBlock | CommentLine> | null;
    tokens?: Array<any> | null;
  }

  declare export interface ForInStatement extends BaseNode {
    type: 'ForInStatement';
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
  }

  declare export interface ForStatement extends BaseNode {
    type: 'ForStatement';
    init?: VariableDeclaration | Expression | null;
    test?: Expression | null;
    update?: Expression | null;
    body: Statement;
  }

  declare export interface FunctionDeclaration extends BaseNode {
    type: 'FunctionDeclaration';
    id?: Identifier | null;
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement;
    generator?: boolean;
    async?: boolean;
    declare?: boolean | null;
    predicate?: DeclaredPredicate | InferredPredicate | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface FunctionExpression extends BaseNode {
    type: 'FunctionExpression';
    id?: Identifier | null;
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement;
    generator?: boolean;
    async?: boolean;
    predicate?: DeclaredPredicate | InferredPredicate | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface Identifier extends BaseNode {
    type: 'Identifier';
    name: string;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
  }

  declare export interface IfStatement extends BaseNode {
    type: 'IfStatement';
    test: Expression;
    consequent: Statement;
    alternate?: Statement | null;
  }

  declare export interface LabeledStatement extends BaseNode {
    type: 'LabeledStatement';
    label: Identifier;
    body: Statement;
  }

  declare export interface StringLiteral extends BaseNode {
    type: 'StringLiteral';
    value: string;
  }

  declare export interface NumericLiteral extends BaseNode {
    type: 'NumericLiteral';
    value: number;
  }

  /**
   * @deprecated Use `NumericLiteral`
   */
  declare export interface NumberLiteral extends BaseNode {
    type: 'NumberLiteral';
    value: number;
  }

  declare export interface NullLiteral extends BaseNode {
    type: 'NullLiteral';
  }

  declare export interface BooleanLiteral extends BaseNode {
    type: 'BooleanLiteral';
    value: boolean;
  }

  declare export interface RegExpLiteral extends BaseNode {
    type: 'RegExpLiteral';
    pattern: string;
    flags: string;
  }

  /**
   * @deprecated Use `RegExpLiteral`
   */
  declare export interface RegexLiteral extends BaseNode {
    type: 'RegexLiteral';
    pattern: string;
    flags: string;
  }

  declare export interface LogicalExpression extends BaseNode {
    type: 'LogicalExpression';
    operator: '||' | '&&' | '??';
    left: Expression;
    right: Expression;
  }

  declare export interface MemberExpression extends BaseNode {
    type: 'MemberExpression';
    object: Expression;
    property: Expression | Identifier | PrivateName;
    computed: boolean;
    optional?: true | false | null;
  }

  declare export interface NewExpression extends BaseNode {
    type: 'NewExpression';
    callee: Expression | V8IntrinsicIdentifier;
    arguments: Array<
      Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder
    >;
    optional?: true | false | null;
    typeArguments?: TypeParameterInstantiation | null;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface Program extends BaseNode {
    type: 'Program';
    body: Array<Statement>;
    directives: Array<Directive>;
    sourceType: 'script' | 'module';
    interpreter?: InterpreterDirective | null;
    sourceFile: string;
  }

  declare export interface ObjectExpression extends BaseNode {
    type: 'ObjectExpression';
    properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
  }

  declare export interface ObjectMethod extends BaseNode {
    type: 'ObjectMethod';
    kind: 'method' | 'get' | 'set';
    key: Expression | Identifier | StringLiteral | NumericLiteral;
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement;
    computed: boolean;
    generator?: boolean;
    async?: boolean;
    decorators?: Array<Decorator> | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface ObjectProperty extends BaseNode {
    type: 'ObjectProperty';
    key:
      | Expression
      | Identifier
      | StringLiteral
      | NumericLiteral
      | BigIntLiteral
      | DecimalLiteral
      | PrivateName;
    value: Expression | PatternLike;
    computed: boolean;
    shorthand: boolean;
    decorators?: Array<Decorator> | null;
  }

  declare export interface RestElement extends BaseNode {
    type: 'RestElement';
    argument: LVal;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
  }

  /**
   * @deprecated Use `RestElement`
   */
  declare export interface RestProperty extends BaseNode {
    type: 'RestProperty';
    argument: LVal;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
  }

  declare export interface ReturnStatement extends BaseNode {
    type: 'ReturnStatement';
    argument?: Expression | null;
  }

  declare export interface SequenceExpression extends BaseNode {
    type: 'SequenceExpression';
    expressions: Array<Expression>;
  }

  declare export interface ParenthesizedExpression extends BaseNode {
    type: 'ParenthesizedExpression';
    expression: Expression;
  }

  declare export interface SwitchCase extends BaseNode {
    type: 'SwitchCase';
    test?: Expression | null;
    consequent: Array<Statement>;
  }

  declare export interface SwitchStatement extends BaseNode {
    type: 'SwitchStatement';
    discriminant: Expression;
    cases: Array<SwitchCase>;
  }

  declare export interface ThisExpression extends BaseNode {
    type: 'ThisExpression';
  }

  declare export interface ThrowStatement extends BaseNode {
    type: 'ThrowStatement';
    argument: Expression;
  }

  declare export interface TryStatement extends BaseNode {
    type: 'TryStatement';
    block: BlockStatement;
    handler?: CatchClause | null;
    finalizer?: BlockStatement | null;
  }

  declare export interface UnaryExpression extends BaseNode {
    type: 'UnaryExpression';
    operator: 'void' | 'throw' | 'delete' | '!' | '+' | '-' | '~' | 'typeof';
    argument: Expression;
    prefix: boolean;
  }

  declare export interface UpdateExpression extends BaseNode {
    type: 'UpdateExpression';
    operator: '++' | '--';
    argument: Expression;
    prefix: boolean;
  }

  declare export interface VariableDeclaration extends BaseNode {
    type: 'VariableDeclaration';
    kind: 'var' | 'let' | 'const';
    declarations: Array<VariableDeclarator>;
    declare?: boolean | null;
  }

  declare export interface VariableDeclarator extends BaseNode {
    type: 'VariableDeclarator';
    id: LVal;
    init?: Expression | null;
    definite?: boolean | null;
  }

  declare export interface WhileStatement extends BaseNode {
    type: 'WhileStatement';
    test: Expression;
    body: Statement;
  }

  declare export interface WithStatement extends BaseNode {
    type: 'WithStatement';
    object: Expression;
    body: Statement;
  }

  declare export interface AssignmentPattern extends BaseNode {
    type: 'AssignmentPattern';
    left:
      | Identifier
      | ObjectPattern
      | ArrayPattern
      | MemberExpression
      | TSAsExpression
      | TSTypeAssertion
      | TSNonNullExpression;
    right: Expression;
    decorators?: Array<Decorator> | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
  }

  declare export interface ArrayPattern extends BaseNode {
    type: 'ArrayPattern';
    elements: Array<null | PatternLike>;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
  }

  declare export interface ArrowFunctionExpression extends BaseNode {
    type: 'ArrowFunctionExpression';
    params: Array<Identifier | Pattern | RestElement>;
    body: BlockStatement | Expression;
    async?: boolean;
    expression: boolean;
    generator?: boolean;
    predicate?: DeclaredPredicate | InferredPredicate | null;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface ClassBody extends BaseNode {
    type: 'ClassBody';
    body: Array<
      | ClassMethod
      | ClassPrivateMethod
      | ClassProperty
      | ClassPrivateProperty
      | ClassAccessorProperty
      | TSDeclareMethod
      | TSIndexSignature
      | StaticBlock
    >;
  }

  declare export interface ClassExpression extends BaseNode {
    type: 'ClassExpression';
    id?: Identifier | null;
    superClass?: Expression | null;
    body: ClassBody;
    decorators?: Array<Decorator> | null;
    implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
    mixins?: InterfaceExtends | null;
    superTypeParameters?:
      | TypeParameterInstantiation
      | TSTypeParameterInstantiation
      | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface ClassDeclaration extends BaseNode {
    type: 'ClassDeclaration';
    id: Identifier;
    superClass?: Expression | null;
    body: ClassBody;
    decorators?: Array<Decorator> | null;
    abstract?: boolean | null;
    declare?: boolean | null;
    implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
    mixins?: InterfaceExtends | null;
    superTypeParameters?:
      | TypeParameterInstantiation
      | TSTypeParameterInstantiation
      | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface ExportAllDeclaration extends BaseNode {
    type: 'ExportAllDeclaration';
    source: StringLiteral;
    assertions?: Array<ImportAttribute> | null;
    exportKind?: 'type' | 'value' | null;
  }

  declare export interface ExportDefaultDeclaration extends BaseNode {
    type: 'ExportDefaultDeclaration';
    declaration: FunctionDeclaration | ClassDeclaration | Expression;
    exportKind?: 'value' | null;
  }

  declare export interface ExportNamedDeclaration extends BaseNode {
    type: 'ExportNamedDeclaration';
    declaration?: Declaration | null;
    specifiers: Array<
      ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier
    >;
    source?: StringLiteral | null;
    assertions?: Array<ImportAttribute> | null;
    exportKind?: 'type' | 'value' | null;
  }

  declare export interface ExportSpecifier extends BaseNode {
    type: 'ExportSpecifier';
    local: Identifier;
    exported: Identifier | StringLiteral;
    exportKind?: 'type' | 'value' | null;
  }

  declare export interface ForOfStatement extends BaseNode {
    type: 'ForOfStatement';
    left: VariableDeclaration | LVal;
    right: Expression;
    body: Statement;
    await: boolean;
  }

  declare export interface ImportDeclaration extends BaseNode {
    type: 'ImportDeclaration';
    specifiers: Array<
      ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier
    >;
    source: StringLiteral;
    assertions?: Array<ImportAttribute> | null;
    importKind?: 'type' | 'typeof' | 'value' | null;
  }

  declare export interface ImportDefaultSpecifier extends BaseNode {
    type: 'ImportDefaultSpecifier';
    local: Identifier;
  }

  declare export interface ImportNamespaceSpecifier extends BaseNode {
    type: 'ImportNamespaceSpecifier';
    local: Identifier;
  }

  declare export interface ImportSpecifier extends BaseNode {
    type: 'ImportSpecifier';
    local: Identifier;
    imported: Identifier | StringLiteral;
    importKind?: 'type' | 'typeof' | 'value' | null;
  }

  declare export interface MetaProperty extends BaseNode {
    type: 'MetaProperty';
    meta: Identifier;
    property: Identifier;
  }

  declare export interface ClassMethod extends BaseNode {
    type: 'ClassMethod';
    kind?: 'get' | 'set' | 'method' | 'constructor';
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
    body: BlockStatement;
    computed?: boolean;
    static?: boolean;
    generator?: boolean;
    async?: boolean;
    abstract?: boolean | null;
    access?: 'public' | 'private' | 'protected' | null;
    accessibility?: 'public' | 'private' | 'protected' | null;
    decorators?: Array<Decorator> | null;
    optional?: boolean | null;
    override?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface ObjectPattern extends BaseNode {
    type: 'ObjectPattern';
    properties: Array<RestElement | ObjectProperty>;
    decorators?: Array<Decorator> | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
  }

  declare export interface SpreadElement extends BaseNode {
    type: 'SpreadElement';
    argument: Expression;
  }

  /**
   * @deprecated Use `SpreadElement`
   */
  declare export interface SpreadProperty extends BaseNode {
    type: 'SpreadProperty';
    argument: Expression;
  }

  declare export interface Super extends BaseNode {
    type: 'Super';
  }

  declare export interface TaggedTemplateExpression extends BaseNode {
    type: 'TaggedTemplateExpression';
    tag: Expression;
    quasi: TemplateLiteral;
    typeParameters?:
      | TypeParameterInstantiation
      | TSTypeParameterInstantiation
      | null;
  }

  declare export interface TemplateElement extends BaseNode {
    type: 'TemplateElement';
    value: { raw: string, cooked?: string };
    tail: boolean;
  }

  declare export interface TemplateLiteral extends BaseNode {
    type: 'TemplateLiteral';
    quasis: Array<TemplateElement>;
    expressions: Array<Expression | TSType>;
  }

  declare export interface YieldExpression extends BaseNode {
    type: 'YieldExpression';
    argument?: Expression | null;
    delegate: boolean;
  }

  declare export interface AwaitExpression extends BaseNode {
    type: 'AwaitExpression';
    argument: Expression;
  }

  declare export interface Import extends BaseNode {
    type: 'Import';
  }

  declare export interface BigIntLiteral extends BaseNode {
    type: 'BigIntLiteral';
    value: string;
  }

  declare export interface ExportNamespaceSpecifier extends BaseNode {
    type: 'ExportNamespaceSpecifier';
    exported: Identifier;
  }

  declare export interface OptionalMemberExpression extends BaseNode {
    type: 'OptionalMemberExpression';
    object: Expression;
    property: Expression | Identifier;
    computed: boolean;
    optional: boolean;
  }

  declare export interface OptionalCallExpression extends BaseNode {
    type: 'OptionalCallExpression';
    callee: Expression;
    arguments: Array<
      Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder
    >;
    optional: boolean;
    typeArguments?: TypeParameterInstantiation | null;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface ClassProperty extends BaseNode {
    type: 'ClassProperty';
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    value?: Expression | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    decorators?: Array<Decorator> | null;
    computed?: boolean;
    static?: boolean;
    abstract?: boolean | null;
    accessibility?: 'public' | 'private' | 'protected' | null;
    declare?: boolean | null;
    definite?: boolean | null;
    optional?: boolean | null;
    override?: boolean;
    readonly?: boolean | null;
    variance?: Variance | null;
  }

  declare export interface ClassAccessorProperty extends BaseNode {
    type: 'ClassAccessorProperty';
    key: Identifier | StringLiteral | NumericLiteral | Expression | PrivateName;
    value?: Expression | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    decorators?: Array<Decorator> | null;
    computed?: boolean;
    static?: boolean;
    abstract?: boolean | null;
    accessibility?: 'public' | 'private' | 'protected' | null;
    declare?: boolean | null;
    definite?: boolean | null;
    optional?: boolean | null;
    override?: boolean;
    readonly?: boolean | null;
    variance?: Variance | null;
  }

  declare export interface ClassPrivateProperty extends BaseNode {
    type: 'ClassPrivateProperty';
    key: PrivateName;
    value?: Expression | null;
    decorators?: Array<Decorator> | null;
    static: any;
    definite?: boolean | null;
    readonly?: boolean | null;
    typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    variance?: Variance | null;
  }

  declare export interface ClassPrivateMethod extends BaseNode {
    type: 'ClassPrivateMethod';
    kind?: 'get' | 'set' | 'method' | 'constructor';
    key: PrivateName;
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
    body: BlockStatement;
    static?: boolean;
    abstract?: boolean | null;
    access?: 'public' | 'private' | 'protected' | null;
    accessibility?: 'public' | 'private' | 'protected' | null;
    async?: boolean;
    computed?: boolean;
    decorators?: Array<Decorator> | null;
    generator?: boolean;
    optional?: boolean | null;
    override?: boolean;
    returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
    typeParameters?:
      | TypeParameterDeclaration
      | TSTypeParameterDeclaration
      | Noop
      | null;
  }

  declare export interface PrivateName extends BaseNode {
    type: 'PrivateName';
    id: Identifier;
  }

  declare export interface StaticBlock extends BaseNode {
    type: 'StaticBlock';
    body: Array<Statement>;
  }

  declare export interface AnyTypeAnnotation extends BaseNode {
    type: 'AnyTypeAnnotation';
  }

  declare export interface ArrayTypeAnnotation extends BaseNode {
    type: 'ArrayTypeAnnotation';
    elementType: FlowType;
  }

  declare export interface BooleanTypeAnnotation extends BaseNode {
    type: 'BooleanTypeAnnotation';
  }

  declare export interface BooleanLiteralTypeAnnotation extends BaseNode {
    type: 'BooleanLiteralTypeAnnotation';
    value: boolean;
  }

  declare export interface NullLiteralTypeAnnotation extends BaseNode {
    type: 'NullLiteralTypeAnnotation';
  }

  declare export interface ClassImplements extends BaseNode {
    type: 'ClassImplements';
    id: Identifier;
    typeParameters?: TypeParameterInstantiation | null;
  }

  declare export interface DeclareClass extends BaseNode {
    type: 'DeclareClass';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    extends?: Array<InterfaceExtends> | null;
    body: ObjectTypeAnnotation;
    implements?: Array<ClassImplements> | null;
    mixins?: Array<InterfaceExtends> | null;
  }

  declare export interface DeclareFunction extends BaseNode {
    type: 'DeclareFunction';
    id: Identifier;
    predicate?: DeclaredPredicate | null;
  }

  declare export interface DeclareInterface extends BaseNode {
    type: 'DeclareInterface';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    extends?: Array<InterfaceExtends> | null;
    body: ObjectTypeAnnotation;
    implements?: Array<ClassImplements> | null;
    mixins?: Array<InterfaceExtends> | null;
  }

  declare export interface DeclareModule extends BaseNode {
    type: 'DeclareModule';
    id: Identifier | StringLiteral;
    body: BlockStatement;
    kind?: 'CommonJS' | 'ES' | null;
  }

  declare export interface DeclareModuleExports extends BaseNode {
    type: 'DeclareModuleExports';
    typeAnnotation: TypeAnnotation;
  }

  declare export interface DeclareTypeAlias extends BaseNode {
    type: 'DeclareTypeAlias';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    right: FlowType;
  }

  declare export interface DeclareOpaqueType extends BaseNode {
    type: 'DeclareOpaqueType';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    supertype?: FlowType | null;
    impltype?: FlowType | null;
  }

  declare export interface DeclareVariable extends BaseNode {
    type: 'DeclareVariable';
    id: Identifier;
  }

  declare export interface DeclareExportDeclaration extends BaseNode {
    type: 'DeclareExportDeclaration';
    declaration?: Flow | null;
    specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null;
    source?: StringLiteral | null;
    default?: boolean | null;
  }

  declare export interface DeclareExportAllDeclaration extends BaseNode {
    type: 'DeclareExportAllDeclaration';
    source: StringLiteral;
    exportKind?: 'type' | 'value' | null;
  }

  declare export interface DeclaredPredicate extends BaseNode {
    type: 'DeclaredPredicate';
    value: Flow;
  }

  declare export interface ExistsTypeAnnotation extends BaseNode {
    type: 'ExistsTypeAnnotation';
  }

  declare export interface FunctionTypeAnnotation extends BaseNode {
    type: 'FunctionTypeAnnotation';
    typeParameters?: TypeParameterDeclaration | null;
    params: Array<FunctionTypeParam>;
    rest?: FunctionTypeParam | null;
    returnType: FlowType;
    this?: FunctionTypeParam | null;
  }

  declare export interface FunctionTypeParam extends BaseNode {
    type: 'FunctionTypeParam';
    name?: Identifier | null;
    typeAnnotation: FlowType;
    optional?: boolean | null;
  }

  declare export interface GenericTypeAnnotation extends BaseNode {
    type: 'GenericTypeAnnotation';
    id: Identifier | QualifiedTypeIdentifier;
    typeParameters?: TypeParameterInstantiation | null;
  }

  declare export interface InferredPredicate extends BaseNode {
    type: 'InferredPredicate';
  }

  declare export interface InterfaceExtends extends BaseNode {
    type: 'InterfaceExtends';
    id: Identifier | QualifiedTypeIdentifier;
    typeParameters?: TypeParameterInstantiation | null;
  }

  declare export interface InterfaceDeclaration extends BaseNode {
    type: 'InterfaceDeclaration';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    extends?: Array<InterfaceExtends> | null;
    body: ObjectTypeAnnotation;
    implements?: Array<ClassImplements> | null;
    mixins?: Array<InterfaceExtends> | null;
  }

  declare export interface InterfaceTypeAnnotation extends BaseNode {
    type: 'InterfaceTypeAnnotation';
    extends?: Array<InterfaceExtends> | null;
    body: ObjectTypeAnnotation;
  }

  declare export interface IntersectionTypeAnnotation extends BaseNode {
    type: 'IntersectionTypeAnnotation';
    types: Array<FlowType>;
  }

  declare export interface MixedTypeAnnotation extends BaseNode {
    type: 'MixedTypeAnnotation';
  }

  declare export interface EmptyTypeAnnotation extends BaseNode {
    type: 'EmptyTypeAnnotation';
  }

  declare export interface NullableTypeAnnotation extends BaseNode {
    type: 'NullableTypeAnnotation';
    typeAnnotation: FlowType;
  }

  declare export interface NumberLiteralTypeAnnotation extends BaseNode {
    type: 'NumberLiteralTypeAnnotation';
    value: number;
  }

  declare export interface NumberTypeAnnotation extends BaseNode {
    type: 'NumberTypeAnnotation';
  }

  declare export interface ObjectTypeAnnotation extends BaseNode {
    type: 'ObjectTypeAnnotation';
    properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>;
    indexers?: Array<ObjectTypeIndexer>;
    callProperties?: Array<ObjectTypeCallProperty>;
    internalSlots?: Array<ObjectTypeInternalSlot>;
    exact: boolean;
    inexact?: boolean | null;
  }

  declare export interface ObjectTypeInternalSlot extends BaseNode {
    type: 'ObjectTypeInternalSlot';
    id: Identifier;
    value: FlowType;
    optional: boolean;
    static: boolean;
    method: boolean;
  }

  declare export interface ObjectTypeCallProperty extends BaseNode {
    type: 'ObjectTypeCallProperty';
    value: FlowType;
    static: boolean;
  }

  declare export interface ObjectTypeIndexer extends BaseNode {
    type: 'ObjectTypeIndexer';
    id?: Identifier | null;
    key: FlowType;
    value: FlowType;
    variance?: Variance | null;
    static: boolean;
  }

  declare export interface ObjectTypeProperty extends BaseNode {
    type: 'ObjectTypeProperty';
    key: Identifier | StringLiteral;
    value: FlowType;
    variance?: Variance | null;
    kind: 'init' | 'get' | 'set';
    method: boolean;
    optional: boolean;
    proto: boolean;
    static: boolean;
  }

  declare export interface ObjectTypeSpreadProperty extends BaseNode {
    type: 'ObjectTypeSpreadProperty';
    argument: FlowType;
  }

  declare export interface OpaqueType extends BaseNode {
    type: 'OpaqueType';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    supertype?: FlowType | null;
    impltype: FlowType;
  }

  declare export interface QualifiedTypeIdentifier extends BaseNode {
    type: 'QualifiedTypeIdentifier';
    id: Identifier;
    qualification: Identifier | QualifiedTypeIdentifier;
  }

  declare export interface StringLiteralTypeAnnotation extends BaseNode {
    type: 'StringLiteralTypeAnnotation';
    value: string;
  }

  declare export interface StringTypeAnnotation extends BaseNode {
    type: 'StringTypeAnnotation';
  }

  declare export interface SymbolTypeAnnotation extends BaseNode {
    type: 'SymbolTypeAnnotation';
  }

  declare export interface ThisTypeAnnotation extends BaseNode {
    type: 'ThisTypeAnnotation';
  }

  declare export interface TupleTypeAnnotation extends BaseNode {
    type: 'TupleTypeAnnotation';
    types: Array<FlowType>;
  }

  declare export interface TypeofTypeAnnotation extends BaseNode {
    type: 'TypeofTypeAnnotation';
    argument: FlowType;
  }

  declare export interface TypeAlias extends BaseNode {
    type: 'TypeAlias';
    id: Identifier;
    typeParameters?: TypeParameterDeclaration | null;
    right: FlowType;
  }

  declare export interface TypeAnnotation extends BaseNode {
    type: 'TypeAnnotation';
    typeAnnotation: FlowType;
  }

  declare export interface TypeCastExpression extends BaseNode {
    type: 'TypeCastExpression';
    expression: Expression;
    typeAnnotation: TypeAnnotation;
  }

  declare export interface TypeParameter extends BaseNode {
    type: 'TypeParameter';
    bound?: TypeAnnotation | null;
    default?: FlowType | null;
    variance?: Variance | null;
    name: string;
  }

  declare export interface TypeParameterDeclaration extends BaseNode {
    type: 'TypeParameterDeclaration';
    params: Array<TypeParameter>;
  }

  declare export interface TypeParameterInstantiation extends BaseNode {
    type: 'TypeParameterInstantiation';
    params: Array<FlowType>;
  }

  declare export interface UnionTypeAnnotation extends BaseNode {
    type: 'UnionTypeAnnotation';
    types: Array<FlowType>;
  }

  declare export interface Variance extends BaseNode {
    type: 'Variance';
    kind: 'minus' | 'plus';
  }

  declare export interface VoidTypeAnnotation extends BaseNode {
    type: 'VoidTypeAnnotation';
  }

  declare export interface EnumDeclaration extends BaseNode {
    type: 'EnumDeclaration';
    id: Identifier;
    body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
  }

  declare export interface EnumBooleanBody extends BaseNode {
    type: 'EnumBooleanBody';
    members: Array<EnumBooleanMember>;
    explicitType: boolean;
    hasUnknownMembers: boolean;
  }

  declare export interface EnumNumberBody extends BaseNode {
    type: 'EnumNumberBody';
    members: Array<EnumNumberMember>;
    explicitType: boolean;
    hasUnknownMembers: boolean;
  }

  declare export interface EnumStringBody extends BaseNode {
    type: 'EnumStringBody';
    members: Array<EnumStringMember | EnumDefaultedMember>;
    explicitType: boolean;
    hasUnknownMembers: boolean;
  }

  declare export interface EnumSymbolBody extends BaseNode {
    type: 'EnumSymbolBody';
    members: Array<EnumDefaultedMember>;
    hasUnknownMembers: boolean;
  }

  declare export interface EnumBooleanMember extends BaseNode {
    type: 'EnumBooleanMember';
    id: Identifier;
    init: BooleanLiteral;
  }

  declare export interface EnumNumberMember extends BaseNode {
    type: 'EnumNumberMember';
    id: Identifier;
    init: NumericLiteral;
  }

  declare export interface EnumStringMember extends BaseNode {
    type: 'EnumStringMember';
    id: Identifier;
    init: StringLiteral;
  }

  declare export interface EnumDefaultedMember extends BaseNode {
    type: 'EnumDefaultedMember';
    id: Identifier;
  }

  declare export interface IndexedAccessType extends BaseNode {
    type: 'IndexedAccessType';
    objectType: FlowType;
    indexType: FlowType;
  }

  declare export interface OptionalIndexedAccessType extends BaseNode {
    type: 'OptionalIndexedAccessType';
    objectType: FlowType;
    indexType: FlowType;
    optional: boolean;
  }

  declare export interface JSXAttribute extends BaseNode {
    type: 'JSXAttribute';
    name: JSXIdentifier | JSXNamespacedName;
    value?:
      | JSXElement
      | JSXFragment
      | StringLiteral
      | JSXExpressionContainer
      | null;
  }

  declare export interface JSXClosingElement extends BaseNode {
    type: 'JSXClosingElement';
    name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
  }

  declare export interface JSXElement extends BaseNode {
    type: 'JSXElement';
    openingElement: JSXOpeningElement;
    closingElement?: JSXClosingElement | null;
    children: Array<
      | JSXText
      | JSXExpressionContainer
      | JSXSpreadChild
      | JSXElement
      | JSXFragment
    >;
    selfClosing?: boolean | null;
  }

  declare export interface JSXEmptyExpression extends BaseNode {
    type: 'JSXEmptyExpression';
  }

  declare export interface JSXExpressionContainer extends BaseNode {
    type: 'JSXExpressionContainer';
    expression: Expression | JSXEmptyExpression;
  }

  declare export interface JSXSpreadChild extends BaseNode {
    type: 'JSXSpreadChild';
    expression: Expression;
  }

  declare export interface JSXIdentifier extends BaseNode {
    type: 'JSXIdentifier';
    name: string;
  }

  declare export interface JSXMemberExpression extends BaseNode {
    type: 'JSXMemberExpression';
    object: JSXMemberExpression | JSXIdentifier;
    property: JSXIdentifier;
  }

  declare export interface JSXNamespacedName extends BaseNode {
    type: 'JSXNamespacedName';
    namespace: JSXIdentifier;
    name: JSXIdentifier;
  }

  declare export interface JSXOpeningElement extends BaseNode {
    type: 'JSXOpeningElement';
    name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
    attributes: Array<JSXAttribute | JSXSpreadAttribute>;
    selfClosing: boolean;
    typeParameters?:
      | TypeParameterInstantiation
      | TSTypeParameterInstantiation
      | null;
  }

  declare export interface JSXSpreadAttribute extends BaseNode {
    type: 'JSXSpreadAttribute';
    argument: Expression;
  }

  declare export interface JSXText extends BaseNode {
    type: 'JSXText';
    value: string;
  }

  declare export interface JSXFragment extends BaseNode {
    type: 'JSXFragment';
    openingFragment: JSXOpeningFragment;
    closingFragment: JSXClosingFragment;
    children: Array<
      | JSXText
      | JSXExpressionContainer
      | JSXSpreadChild
      | JSXElement
      | JSXFragment
    >;
  }

  declare export interface JSXOpeningFragment extends BaseNode {
    type: 'JSXOpeningFragment';
  }

  declare export interface JSXClosingFragment extends BaseNode {
    type: 'JSXClosingFragment';
  }

  declare export interface Noop extends BaseNode {
    type: 'Noop';
  }

  declare export interface Placeholder extends BaseNode {
    type: 'Placeholder';
    expectedNode:
      | 'Identifier'
      | 'StringLiteral'
      | 'Expression'
      | 'Statement'
      | 'Declaration'
      | 'BlockStatement'
      | 'ClassBody'
      | 'Pattern';
    name: Identifier;
  }

  declare export interface V8IntrinsicIdentifier extends BaseNode {
    type: 'V8IntrinsicIdentifier';
    name: string;
  }

  declare export interface ArgumentPlaceholder extends BaseNode {
    type: 'ArgumentPlaceholder';
  }

  declare export interface BindExpression extends BaseNode {
    type: 'BindExpression';
    object: Expression;
    callee: Expression;
  }

  declare export interface ImportAttribute extends BaseNode {
    type: 'ImportAttribute';
    key: Identifier | StringLiteral;
    value: StringLiteral;
  }

  declare export interface Decorator extends BaseNode {
    type: 'Decorator';
    expression: Expression;
  }

  declare export interface DoExpression extends BaseNode {
    type: 'DoExpression';
    body: BlockStatement;
    async: boolean;
  }

  declare export interface ExportDefaultSpecifier extends BaseNode {
    type: 'ExportDefaultSpecifier';
    exported: Identifier;
  }

  declare export interface RecordExpression extends BaseNode {
    type: 'RecordExpression';
    properties: Array<ObjectProperty | SpreadElement>;
  }

  declare export interface TupleExpression extends BaseNode {
    type: 'TupleExpression';
    elements: Array<Expression | SpreadElement>;
  }

  declare export interface DecimalLiteral extends BaseNode {
    type: 'DecimalLiteral';
    value: string;
  }

  declare export interface ModuleExpression extends BaseNode {
    type: 'ModuleExpression';
    body: Program;
  }

  declare export interface TopicReference extends BaseNode {
    type: 'TopicReference';
  }

  declare export interface PipelineTopicExpression extends BaseNode {
    type: 'PipelineTopicExpression';
    expression: Expression;
  }

  declare export interface PipelineBareFunction extends BaseNode {
    type: 'PipelineBareFunction';
    callee: Expression;
  }

  declare export interface PipelinePrimaryTopicReference extends BaseNode {
    type: 'PipelinePrimaryTopicReference';
  }

  declare export interface TSParameterProperty extends BaseNode {
    type: 'TSParameterProperty';
    parameter: Identifier | AssignmentPattern;
    accessibility?: 'public' | 'private' | 'protected' | null;
    decorators?: Array<Decorator> | null;
    override?: boolean | null;
    readonly?: boolean | null;
  }

  declare export interface TSDeclareFunction extends BaseNode {
    type: 'TSDeclareFunction';
    id?: Identifier | null;
    typeParameters?: TSTypeParameterDeclaration | Noop | null;
    params: Array<Identifier | Pattern | RestElement>;
    returnType?: TSTypeAnnotation | Noop | null;
    async?: boolean;
    declare?: boolean | null;
    generator?: boolean;
  }

  declare export interface TSDeclareMethod extends BaseNode {
    type: 'TSDeclareMethod';
    decorators?: Array<Decorator> | null;
    key: Identifier | StringLiteral | NumericLiteral | Expression;
    typeParameters?: TSTypeParameterDeclaration | Noop | null;
    params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
    returnType?: TSTypeAnnotation | Noop | null;
    abstract?: boolean | null;
    access?: 'public' | 'private' | 'protected' | null;
    accessibility?: 'public' | 'private' | 'protected' | null;
    async?: boolean;
    computed?: boolean;
    generator?: boolean;
    kind?: 'get' | 'set' | 'method' | 'constructor';
    optional?: boolean | null;
    override?: boolean;
    static?: boolean;
  }

  declare export interface TSQualifiedName extends BaseNode {
    type: 'TSQualifiedName';
    left: TSEntityName;
    right: Identifier;
  }

  declare export interface TSCallSignatureDeclaration extends BaseNode {
    type: 'TSCallSignatureDeclaration';
    typeParameters?: TSTypeParameterDeclaration | null;
    parameters: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation | null;
  }

  declare export interface TSConstructSignatureDeclaration extends BaseNode {
    type: 'TSConstructSignatureDeclaration';
    typeParameters?: TSTypeParameterDeclaration | null;
    parameters: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation | null;
  }

  declare export interface TSPropertySignature extends BaseNode {
    type: 'TSPropertySignature';
    key: Expression;
    typeAnnotation?: TSTypeAnnotation | null;
    initializer?: Expression | null;
    computed?: boolean | null;
    kind: 'get' | 'set';
    optional?: boolean | null;
    readonly?: boolean | null;
  }

  declare export interface TSMethodSignature extends BaseNode {
    type: 'TSMethodSignature';
    key: Expression;
    typeParameters?: TSTypeParameterDeclaration | null;
    parameters: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation | null;
    computed?: boolean | null;
    kind: 'method' | 'get' | 'set';
    optional?: boolean | null;
  }

  declare export interface TSIndexSignature extends BaseNode {
    type: 'TSIndexSignature';
    parameters: Array<Identifier>;
    typeAnnotation?: TSTypeAnnotation | null;
    readonly?: boolean | null;
    static?: boolean | null;
  }

  declare export interface TSAnyKeyword extends BaseNode {
    type: 'TSAnyKeyword';
  }

  declare export interface TSBooleanKeyword extends BaseNode {
    type: 'TSBooleanKeyword';
  }

  declare export interface TSBigIntKeyword extends BaseNode {
    type: 'TSBigIntKeyword';
  }

  declare export interface TSIntrinsicKeyword extends BaseNode {
    type: 'TSIntrinsicKeyword';
  }

  declare export interface TSNeverKeyword extends BaseNode {
    type: 'TSNeverKeyword';
  }

  declare export interface TSNullKeyword extends BaseNode {
    type: 'TSNullKeyword';
  }

  declare export interface TSNumberKeyword extends BaseNode {
    type: 'TSNumberKeyword';
  }

  declare export interface TSObjectKeyword extends BaseNode {
    type: 'TSObjectKeyword';
  }

  declare export interface TSStringKeyword extends BaseNode {
    type: 'TSStringKeyword';
  }

  declare export interface TSSymbolKeyword extends BaseNode {
    type: 'TSSymbolKeyword';
  }

  declare export interface TSUndefinedKeyword extends BaseNode {
    type: 'TSUndefinedKeyword';
  }

  declare export interface TSUnknownKeyword extends BaseNode {
    type: 'TSUnknownKeyword';
  }

  declare export interface TSVoidKeyword extends BaseNode {
    type: 'TSVoidKeyword';
  }

  declare export interface TSThisType extends BaseNode {
    type: 'TSThisType';
  }

  declare export interface TSFunctionType extends BaseNode {
    type: 'TSFunctionType';
    typeParameters?: TSTypeParameterDeclaration | null;
    parameters: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation | null;
  }

  declare export interface TSConstructorType extends BaseNode {
    type: 'TSConstructorType';
    typeParameters?: TSTypeParameterDeclaration | null;
    parameters: Array<Identifier | RestElement>;
    typeAnnotation?: TSTypeAnnotation | null;
    abstract?: boolean | null;
  }

  declare export interface TSTypeReference extends BaseNode {
    type: 'TSTypeReference';
    typeName: TSEntityName;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface TSTypePredicate extends BaseNode {
    type: 'TSTypePredicate';
    parameterName: Identifier | TSThisType;
    typeAnnotation?: TSTypeAnnotation | null;
    asserts?: boolean | null;
  }

  declare export interface TSTypeQuery extends BaseNode {
    type: 'TSTypeQuery';
    exprName: TSEntityName | TSImportType;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface TSTypeLiteral extends BaseNode {
    type: 'TSTypeLiteral';
    members: Array<TSTypeElement>;
  }

  declare export interface TSArrayType extends BaseNode {
    type: 'TSArrayType';
    elementType: TSType;
  }

  declare export interface TSTupleType extends BaseNode {
    type: 'TSTupleType';
    elementTypes: Array<TSType | TSNamedTupleMember>;
  }

  declare export interface TSOptionalType extends BaseNode {
    type: 'TSOptionalType';
    typeAnnotation: TSType;
  }

  declare export interface TSRestType extends BaseNode {
    type: 'TSRestType';
    typeAnnotation: TSType;
  }

  declare export interface TSNamedTupleMember extends BaseNode {
    type: 'TSNamedTupleMember';
    label: Identifier;
    elementType: TSType;
    optional: boolean;
  }

  declare export interface TSUnionType extends BaseNode {
    type: 'TSUnionType';
    types: Array<TSType>;
  }

  declare export interface TSIntersectionType extends BaseNode {
    type: 'TSIntersectionType';
    types: Array<TSType>;
  }

  declare export interface TSConditionalType extends BaseNode {
    type: 'TSConditionalType';
    checkType: TSType;
    extendsType: TSType;
    trueType: TSType;
    falseType: TSType;
  }

  declare export interface TSInferType extends BaseNode {
    type: 'TSInferType';
    typeParameter: TSTypeParameter;
  }

  declare export interface TSParenthesizedType extends BaseNode {
    type: 'TSParenthesizedType';
    typeAnnotation: TSType;
  }

  declare export interface TSTypeOperator extends BaseNode {
    type: 'TSTypeOperator';
    typeAnnotation: TSType;
    operator: string;
  }

  declare export interface TSIndexedAccessType extends BaseNode {
    type: 'TSIndexedAccessType';
    objectType: TSType;
    indexType: TSType;
  }

  declare export interface TSMappedType extends BaseNode {
    type: 'TSMappedType';
    typeParameter: TSTypeParameter;
    typeAnnotation?: TSType | null;
    nameType?: TSType | null;
    optional?: true | false | '+' | '-' | null;
    readonly?: true | false | '+' | '-' | null;
  }

  declare export interface TSLiteralType extends BaseNode {
    type: 'TSLiteralType';
    literal:
      | NumericLiteral
      | StringLiteral
      | BooleanLiteral
      | BigIntLiteral
      | UnaryExpression;
  }

  declare export interface TSExpressionWithTypeArguments extends BaseNode {
    type: 'TSExpressionWithTypeArguments';
    expression: TSEntityName;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface TSInterfaceDeclaration extends BaseNode {
    type: 'TSInterfaceDeclaration';
    id: Identifier;
    typeParameters?: TSTypeParameterDeclaration | null;
    extends?: Array<TSExpressionWithTypeArguments> | null;
    body: TSInterfaceBody;
    declare?: boolean | null;
  }

  declare export interface TSInterfaceBody extends BaseNode {
    type: 'TSInterfaceBody';
    body: Array<TSTypeElement>;
  }

  declare export interface TSTypeAliasDeclaration extends BaseNode {
    type: 'TSTypeAliasDeclaration';
    id: Identifier;
    typeParameters?: TSTypeParameterDeclaration | null;
    typeAnnotation: TSType;
    declare?: boolean | null;
  }

  declare export interface TSInstantiationExpression extends BaseNode {
    type: 'TSInstantiationExpression';
    expression: Expression;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface TSAsExpression extends BaseNode {
    type: 'TSAsExpression';
    expression: Expression;
    typeAnnotation: TSType;
  }

  declare export interface TSTypeAssertion extends BaseNode {
    type: 'TSTypeAssertion';
    typeAnnotation: TSType;
    expression: Expression;
  }

  declare export interface TSEnumDeclaration extends BaseNode {
    type: 'TSEnumDeclaration';
    id: Identifier;
    members: Array<TSEnumMember>;
    const?: boolean | null;
    declare?: boolean | null;
    initializer?: Expression | null;
  }

  declare export interface TSEnumMember extends BaseNode {
    type: 'TSEnumMember';
    id: Identifier | StringLiteral;
    initializer?: Expression | null;
  }

  declare export interface TSModuleDeclaration extends BaseNode {
    type: 'TSModuleDeclaration';
    id: Identifier | StringLiteral;
    body: TSModuleBlock | TSModuleDeclaration;
    declare?: boolean | null;
    global?: boolean | null;
  }

  declare export interface TSModuleBlock extends BaseNode {
    type: 'TSModuleBlock';
    body: Array<Statement>;
  }

  declare export interface TSImportType extends BaseNode {
    type: 'TSImportType';
    argument: StringLiteral;
    qualifier?: TSEntityName | null;
    typeParameters?: TSTypeParameterInstantiation | null;
  }

  declare export interface TSImportEqualsDeclaration extends BaseNode {
    type: 'TSImportEqualsDeclaration';
    id: Identifier;
    moduleReference: TSEntityName | TSExternalModuleReference;
    importKind?: 'type' | 'value' | null;
    isExport: boolean;
  }

  declare export interface TSExternalModuleReference extends BaseNode {
    type: 'TSExternalModuleReference';
    expression: StringLiteral;
  }

  declare export interface TSNonNullExpression extends BaseNode {
    type: 'TSNonNullExpression';
    expression: Expression;
  }

  declare export interface TSExportAssignment extends BaseNode {
    type: 'TSExportAssignment';
    expression: Expression;
  }

  declare export interface TSNamespaceExportDeclaration extends BaseNode {
    type: 'TSNamespaceExportDeclaration';
    id: Identifier;
  }

  declare export interface TSTypeAnnotation extends BaseNode {
    type: 'TSTypeAnnotation';
    typeAnnotation: TSType;
  }

  declare export interface TSTypeParameterInstantiation extends BaseNode {
    type: 'TSTypeParameterInstantiation';
    params: Array<TSType>;
  }

  declare export interface TSTypeParameterDeclaration extends BaseNode {
    type: 'TSTypeParameterDeclaration';
    params: Array<TSTypeParameter>;
  }

  declare export interface TSTypeParameter extends BaseNode {
    type: 'TSTypeParameter';
    constraint?: TSType | null;
    default?: TSType | null;
    name: string;
    in?: boolean | null;
    out?: boolean | null;
  }

  declare export type Standardized =
    | ArrayExpression
    | AssignmentExpression
    | BinaryExpression
    | InterpreterDirective
    | Directive
    | DirectiveLiteral
    | BlockStatement
    | BreakStatement
    | CallExpression
    | CatchClause
    | ConditionalExpression
    | ContinueStatement
    | DebuggerStatement
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | File
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Identifier
    | IfStatement
    | LabeledStatement
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | LogicalExpression
    | MemberExpression
    | NewExpression
    | Program
    | ObjectExpression
    | ObjectMethod
    | ObjectProperty
    | RestElement
    | ReturnStatement
    | SequenceExpression
    | ParenthesizedExpression
    | SwitchCase
    | SwitchStatement
    | ThisExpression
    | ThrowStatement
    | TryStatement
    | UnaryExpression
    | UpdateExpression
    | VariableDeclaration
    | VariableDeclarator
    | WhileStatement
    | WithStatement
    | AssignmentPattern
    | ArrayPattern
    | ArrowFunctionExpression
    | ClassBody
    | ClassExpression
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ExportSpecifier
    | ForOfStatement
    | ImportDeclaration
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | MetaProperty
    | ClassMethod
    | ObjectPattern
    | SpreadElement
    | Super
    | TaggedTemplateExpression
    | TemplateElement
    | TemplateLiteral
    | YieldExpression
    | AwaitExpression
    | Import
    | BigIntLiteral
    | ExportNamespaceSpecifier
    | OptionalMemberExpression
    | OptionalCallExpression
    | ClassProperty
    | ClassAccessorProperty
    | ClassPrivateProperty
    | ClassPrivateMethod
    | PrivateName
    | StaticBlock;
  declare export type Expression =
    | ArrayExpression
    | AssignmentExpression
    | BinaryExpression
    | CallExpression
    | ConditionalExpression
    | FunctionExpression
    | Identifier
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | LogicalExpression
    | MemberExpression
    | NewExpression
    | ObjectExpression
    | SequenceExpression
    | ParenthesizedExpression
    | ThisExpression
    | UnaryExpression
    | UpdateExpression
    | ArrowFunctionExpression
    | ClassExpression
    | MetaProperty
    | Super
    | TaggedTemplateExpression
    | TemplateLiteral
    | YieldExpression
    | AwaitExpression
    | Import
    | BigIntLiteral
    | OptionalMemberExpression
    | OptionalCallExpression
    | TypeCastExpression
    | JSXElement
    | JSXFragment
    | BindExpression
    | DoExpression
    | RecordExpression
    | TupleExpression
    | DecimalLiteral
    | ModuleExpression
    | TopicReference
    | PipelineTopicExpression
    | PipelineBareFunction
    | PipelinePrimaryTopicReference
    | TSInstantiationExpression
    | TSAsExpression
    | TSTypeAssertion
    | TSNonNullExpression;
  declare export type Binary = BinaryExpression | LogicalExpression;
  declare export type Scopable =
    | BlockStatement
    | CatchClause
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Program
    | ObjectMethod
    | SwitchStatement
    | WhileStatement
    | ArrowFunctionExpression
    | ClassExpression
    | ClassDeclaration
    | ForOfStatement
    | ClassMethod
    | ClassPrivateMethod
    | StaticBlock
    | TSModuleBlock;
  declare export type BlockParent =
    | BlockStatement
    | CatchClause
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | FunctionExpression
    | Program
    | ObjectMethod
    | SwitchStatement
    | WhileStatement
    | ArrowFunctionExpression
    | ForOfStatement
    | ClassMethod
    | ClassPrivateMethod
    | StaticBlock
    | TSModuleBlock;
  declare export type Block = BlockStatement | Program | TSModuleBlock;
  declare export type Statement =
    | BlockStatement
    | BreakStatement
    | ContinueStatement
    | DebuggerStatement
    | DoWhileStatement
    | EmptyStatement
    | ExpressionStatement
    | ForInStatement
    | ForStatement
    | FunctionDeclaration
    | IfStatement
    | LabeledStatement
    | ReturnStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | VariableDeclaration
    | WhileStatement
    | WithStatement
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ForOfStatement
    | ImportDeclaration
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias
    | EnumDeclaration
    | TSDeclareFunction
    | TSInterfaceDeclaration
    | TSTypeAliasDeclaration
    | TSEnumDeclaration
    | TSModuleDeclaration
    | TSImportEqualsDeclaration
    | TSExportAssignment
    | TSNamespaceExportDeclaration;
  declare export type Terminatorless =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement
    | YieldExpression
    | AwaitExpression;
  declare export type CompletionStatement =
    | BreakStatement
    | ContinueStatement
    | ReturnStatement
    | ThrowStatement;
  declare export type Conditional = ConditionalExpression | IfStatement;
  declare export type Loop =
    | DoWhileStatement
    | ForInStatement
    | ForStatement
    | WhileStatement
    | ForOfStatement;
  declare export type While = DoWhileStatement | WhileStatement;
  declare export type ExpressionWrapper =
    | ExpressionStatement
    | ParenthesizedExpression
    | TypeCastExpression;
  declare export type For = ForInStatement | ForStatement | ForOfStatement;
  declare export type ForXStatement = ForInStatement | ForOfStatement;
  declare export type Function =
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod;
  declare export type FunctionParent =
    | FunctionDeclaration
    | FunctionExpression
    | ObjectMethod
    | ArrowFunctionExpression
    | ClassMethod
    | ClassPrivateMethod
    | StaticBlock;
  declare export type Pureish =
    | FunctionDeclaration
    | FunctionExpression
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | ArrowFunctionExpression
    | BigIntLiteral
    | DecimalLiteral;
  declare export type Declaration =
    | FunctionDeclaration
    | VariableDeclaration
    | ClassDeclaration
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias
    | EnumDeclaration
    | TSDeclareFunction
    | TSInterfaceDeclaration
    | TSTypeAliasDeclaration
    | TSEnumDeclaration
    | TSModuleDeclaration;
  declare export type PatternLike =
    | Identifier
    | RestElement
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern
    | TSAsExpression
    | TSTypeAssertion
    | TSNonNullExpression;
  declare export type LVal =
    | Identifier
    | MemberExpression
    | RestElement
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern
    | TSParameterProperty
    | TSAsExpression
    | TSTypeAssertion
    | TSNonNullExpression;
  declare export type TSEntityName = Identifier | TSQualifiedName;
  declare export type Literal =
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | RegExpLiteral
    | TemplateLiteral
    | BigIntLiteral
    | DecimalLiteral;
  declare export type Immutable =
    | StringLiteral
    | NumericLiteral
    | NullLiteral
    | BooleanLiteral
    | BigIntLiteral
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXOpeningElement
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment
    | DecimalLiteral;
  declare export type UserWhitespacable =
    | ObjectMethod
    | ObjectProperty
    | ObjectTypeInternalSlot
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty;
  declare export type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;
  declare export type ObjectMember = ObjectMethod | ObjectProperty;
  declare export type Property =
    | ObjectProperty
    | ClassProperty
    | ClassAccessorProperty
    | ClassPrivateProperty;
  declare export type UnaryLike = UnaryExpression | SpreadElement;
  declare export type Pattern =
    | AssignmentPattern
    | ArrayPattern
    | ObjectPattern;
  declare export type _Class = ClassExpression | ClassDeclaration;
  declare export type ModuleDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration
    | ImportDeclaration;
  declare export type ExportDeclaration =
    | ExportAllDeclaration
    | ExportDefaultDeclaration
    | ExportNamedDeclaration;
  declare export type ModuleSpecifier =
    | ExportSpecifier
    | ImportDefaultSpecifier
    | ImportNamespaceSpecifier
    | ImportSpecifier
    | ExportNamespaceSpecifier
    | ExportDefaultSpecifier;
  declare export type Accessor = ClassAccessorProperty;
  declare export type Private =
    | ClassPrivateProperty
    | ClassPrivateMethod
    | PrivateName;
  declare export type Flow =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ClassImplements
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | DeclaredPredicate
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | FunctionTypeParam
    | GenericTypeAnnotation
    | InferredPredicate
    | InterfaceExtends
    | InterfaceDeclaration
    | InterfaceTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | ObjectTypeInternalSlot
    | ObjectTypeCallProperty
    | ObjectTypeIndexer
    | ObjectTypeProperty
    | ObjectTypeSpreadProperty
    | OpaqueType
    | QualifiedTypeIdentifier
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | SymbolTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | TypeAlias
    | TypeAnnotation
    | TypeCastExpression
    | TypeParameter
    | TypeParameterDeclaration
    | TypeParameterInstantiation
    | UnionTypeAnnotation
    | Variance
    | VoidTypeAnnotation
    | EnumDeclaration
    | EnumBooleanBody
    | EnumNumberBody
    | EnumStringBody
    | EnumSymbolBody
    | EnumBooleanMember
    | EnumNumberMember
    | EnumStringMember
    | EnumDefaultedMember
    | IndexedAccessType
    | OptionalIndexedAccessType;
  declare export type FlowType =
    | AnyTypeAnnotation
    | ArrayTypeAnnotation
    | BooleanTypeAnnotation
    | BooleanLiteralTypeAnnotation
    | NullLiteralTypeAnnotation
    | ExistsTypeAnnotation
    | FunctionTypeAnnotation
    | GenericTypeAnnotation
    | InterfaceTypeAnnotation
    | IntersectionTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NullableTypeAnnotation
    | NumberLiteralTypeAnnotation
    | NumberTypeAnnotation
    | ObjectTypeAnnotation
    | StringLiteralTypeAnnotation
    | StringTypeAnnotation
    | SymbolTypeAnnotation
    | ThisTypeAnnotation
    | TupleTypeAnnotation
    | TypeofTypeAnnotation
    | UnionTypeAnnotation
    | VoidTypeAnnotation
    | IndexedAccessType
    | OptionalIndexedAccessType;
  declare export type FlowBaseAnnotation =
    | AnyTypeAnnotation
    | BooleanTypeAnnotation
    | NullLiteralTypeAnnotation
    | MixedTypeAnnotation
    | EmptyTypeAnnotation
    | NumberTypeAnnotation
    | StringTypeAnnotation
    | SymbolTypeAnnotation
    | ThisTypeAnnotation
    | VoidTypeAnnotation;
  declare export type FlowDeclaration =
    | DeclareClass
    | DeclareFunction
    | DeclareInterface
    | DeclareModule
    | DeclareModuleExports
    | DeclareTypeAlias
    | DeclareOpaqueType
    | DeclareVariable
    | DeclareExportDeclaration
    | DeclareExportAllDeclaration
    | InterfaceDeclaration
    | OpaqueType
    | TypeAlias;
  declare export type FlowPredicate = DeclaredPredicate | InferredPredicate;
  declare export type EnumBody =
    | EnumBooleanBody
    | EnumNumberBody
    | EnumStringBody
    | EnumSymbolBody;
  declare export type EnumMember =
    | EnumBooleanMember
    | EnumNumberMember
    | EnumStringMember
    | EnumDefaultedMember;
  declare export type JSX =
    | JSXAttribute
    | JSXClosingElement
    | JSXElement
    | JSXEmptyExpression
    | JSXExpressionContainer
    | JSXSpreadChild
    | JSXIdentifier
    | JSXMemberExpression
    | JSXNamespacedName
    | JSXOpeningElement
    | JSXSpreadAttribute
    | JSXText
    | JSXFragment
    | JSXOpeningFragment
    | JSXClosingFragment;
  declare export type Miscellaneous =
    | Noop
    | Placeholder
    | V8IntrinsicIdentifier;
  declare export type TypeScript =
    | TSParameterProperty
    | TSDeclareFunction
    | TSDeclareMethod
    | TSQualifiedName
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSPropertySignature
    | TSMethodSignature
    | TSIndexSignature
    | TSAnyKeyword
    | TSBooleanKeyword
    | TSBigIntKeyword
    | TSIntrinsicKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSFunctionType
    | TSConstructorType
    | TSTypeReference
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeLiteral
    | TSArrayType
    | TSTupleType
    | TSOptionalType
    | TSRestType
    | TSNamedTupleMember
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSParenthesizedType
    | TSTypeOperator
    | TSIndexedAccessType
    | TSMappedType
    | TSLiteralType
    | TSExpressionWithTypeArguments
    | TSInterfaceDeclaration
    | TSInterfaceBody
    | TSTypeAliasDeclaration
    | TSInstantiationExpression
    | TSAsExpression
    | TSTypeAssertion
    | TSEnumDeclaration
    | TSEnumMember
    | TSModuleDeclaration
    | TSModuleBlock
    | TSImportType
    | TSImportEqualsDeclaration
    | TSExternalModuleReference
    | TSNonNullExpression
    | TSExportAssignment
    | TSNamespaceExportDeclaration
    | TSTypeAnnotation
    | TSTypeParameterInstantiation
    | TSTypeParameterDeclaration
    | TSTypeParameter;
  declare export type TSTypeElement =
    | TSCallSignatureDeclaration
    | TSConstructSignatureDeclaration
    | TSPropertySignature
    | TSMethodSignature
    | TSIndexSignature;
  declare export type TSType =
    | TSAnyKeyword
    | TSBooleanKeyword
    | TSBigIntKeyword
    | TSIntrinsicKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSFunctionType
    | TSConstructorType
    | TSTypeReference
    | TSTypePredicate
    | TSTypeQuery
    | TSTypeLiteral
    | TSArrayType
    | TSTupleType
    | TSOptionalType
    | TSRestType
    | TSUnionType
    | TSIntersectionType
    | TSConditionalType
    | TSInferType
    | TSParenthesizedType
    | TSTypeOperator
    | TSIndexedAccessType
    | TSMappedType
    | TSLiteralType
    | TSExpressionWithTypeArguments
    | TSImportType;
  declare export type TSBaseType =
    | TSAnyKeyword
    | TSBooleanKeyword
    | TSBigIntKeyword
    | TSIntrinsicKeyword
    | TSNeverKeyword
    | TSNullKeyword
    | TSNumberKeyword
    | TSObjectKeyword
    | TSStringKeyword
    | TSSymbolKeyword
    | TSUndefinedKeyword
    | TSUnknownKeyword
    | TSVoidKeyword
    | TSThisType
    | TSLiteralType;

  declare export interface Aliases {
    Standardized: Standardized;
    Expression: Expression;
    Binary: Binary;
    Scopable: Scopable;
    BlockParent: BlockParent;
    Block: Block;
    Statement: Statement;
    Terminatorless: Terminatorless;
    CompletionStatement: CompletionStatement;
    Conditional: Conditional;
    Loop: Loop;
    While: While;
    ExpressionWrapper: ExpressionWrapper;
    For: For;
    ForXStatement: ForXStatement;
    Function: Function;
    FunctionParent: FunctionParent;
    Pureish: Pureish;
    Declaration: Declaration;
    PatternLike: PatternLike;
    LVal: LVal;
    TSEntityName: TSEntityName;
    Literal: Literal;
    Immutable: Immutable;
    UserWhitespacable: UserWhitespacable;
    Method: Method;
    ObjectMember: ObjectMember;
    Property: Property;
    UnaryLike: UnaryLike;
    Pattern: Pattern;
    Class: _Class;
    ModuleDeclaration: ModuleDeclaration;
    ExportDeclaration: ExportDeclaration;
    ModuleSpecifier: ModuleSpecifier;
    Accessor: Accessor;
    Private: Private;
    Flow: Flow;
    FlowType: FlowType;
    FlowBaseAnnotation: FlowBaseAnnotation;
    FlowDeclaration: FlowDeclaration;
    FlowPredicate: FlowPredicate;
    EnumBody: EnumBody;
    EnumMember: EnumMember;
    JSX: JSX;
    Miscellaneous: Miscellaneous;
    TypeScript: TypeScript;
    TSTypeElement: TSTypeElement;
    TSType: TSType;
    TSBaseType: TSBaseType;
  }

  declare export type DeprecatedAliases =
    | NumberLiteral
    | RegexLiteral
    | RestProperty
    | SpreadProperty;
}
