/* eslint-disable flowtype/no-types-missing-file-annotation */
// flow-typed signature: 2e6e24fb68d0979765b67c441a9f475c
// flow-typed version: <<STUB>>/@babel/core_v^7.15.5/flow_v0.162.1

/**
 * This is an autogenerated libdef stub for:
 *
 *   '@babel/core'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

// $FlowExpectedError(toplevel-library-import)
import * as t from '@babel/types';
// $FlowExpectedError(toplevel-library-import)
import {
  type Visitor as _Visitor,
  type NodePath,
  type Scope,
} from '@babel/traverse';

declare module '@babel/core' {
  // $FlowExpectedError(value-as-type)
  declare export type types = t;
  // $FlowExpectedError(value-as-type)
  declare export type Node = t.Node;
  // export import template = require('babel-template');
  declare export var version: string;
  declare export var traverse: any;
  // $FlowExpectedError(value-as-type)
  declare export type Visitor<T> = _Visitor<T>;

  // import { BabylonOptions } from "babylon";
  declare export type BabylonOptions = { ... };
  declare export type GeneratorOptions = { ... };

  // A babel plugin is a simple function which must return an object matching
  // the following interface. Babel will throw if it finds unknown properties.
  // The list of allowed plugin keys is here:
  // https://github.com/babel/babel/blob/4e50b2d9d9c376cee7a2cbf56553fe5b982ea53c/packages/babel-core/src/config/option-manager.js#L71
  declare export interface PluginObj<S = { ... }> {
    +name?: string | void;
    +manipulateOptions?: (opts: any, parserOpts: any) => void;
    +pre?: (this: S, state: any) => void;
    +visitor: Visitor<S>;
    +post?: (this: S, state: any) => void;
    +inherits?: any;
  }

  /** Transforms the passed in `code`. Returning an object with the generated code, source map, and AST. */
  declare export function transform(
    code: string,
    opts?: TransformOptions
  ): BabelFileResult;

  /** Asynchronously transforms the entire contents of a file. */
  declare export function transformFile(
    filename: string,
    opts: TransformOptions,
    callback: (err: any, result: BabelFileResult) => void
  ): void;

  /** Synchronous version of `babel.transformFile`. Returns the transformed contents of the `filename`. */
  declare export function transformFileSync(
    filename: string,
    opts?: TransformOptions
  ): BabelFileResult;

  declare export function transformFromAst(
    ast: Node,
    code?: string,
    opts?: TransformOptions
  ): BabelFileResult;

  declare export interface TransformOptions {
    /** Include the AST in the returned object. Default: `true`. */
    ast?: boolean | void;

    /** Attach a comment after all non-user injected code. */
    auxiliaryCommentAfter?: string | void;

    /** Attach a comment before all non-user injected code. */
    auxiliaryCommentBefore?: string | void;

    /** Specify whether or not to use `.babelrc` and `.babelignore` files. Default: `true`. */
    babelrc?: boolean | void;

    /** Enable code generation. Default: `true`. */
    code?: boolean | void;

    /** write comments to generated output. Default: `true`. */
    comments?: boolean | void;

    /**
     * Do not include superfluous whitespace characters and line terminators. When set to `"auto"`, `compact` is set to
     * `true` on input sizes of >100KB.
     */
    compact?: boolean | 'auto' | void;

    /**
     * This is an object of keys that represent different environments. For example, you may have:
     * `{ env: { production: { / * specific options * / } } }`
     * which will use those options when the enviroment variable `BABEL_ENV` is set to `"production"`.
     * If `BABEL_ENV` isn't set then `NODE_ENV` will be used, if it's not set then it defaults to `"development"`.
     */
    env?: { ... } | void;

    /** A path to an .babelrc file to extend. */
    extends?: string | void;

    /** Filename to use when reading from stdin - this will be used in source-maps, errors etc. Default: "unknown". */
    filename?: string | void;

    /** Filename relative to `sourceRoot`. */
    filenameRelative?: string | void;

    /** An object containing the options to be passed down to the babel code generator, babel-generator. Default: `{}` */
    generatorOpts?: GeneratorOptions | void;

    /**
     * Specify a custom callback to generate a module id with. Called as `getModuleId(moduleName)`.
     * If falsy value is returned then the generated module id is used.
     */
    +getModuleId?: (moduleName: string) => string;

    /** Enable/disable ANSI syntax highlighting of code frames. Default: `true`. */
    highlightCode?: boolean | void;

    /** list of glob paths to **not** compile. Opposite to the `only` option. */
    ignore?: Array<string> | void;

    /** A source map object that the output source map will be based on. */
    inputSourceMap?: { ... } | void;

    /** Should the output be minified. Default: `false` */
    minified?: boolean | void;

    /** Specify a custom name for module ids. */
    moduleId?: string | void;

    /**
     * If truthy, insert an explicit id for modules. By default, all modules are anonymous.
     * (Not available for `common` modules).
     */
    moduleIds?: boolean | void;

    /** Optional prefix for the AMD module formatter that will be prepend to the filename on module definitions. */
    moduleRoot?: string | void;

    /**
     * A glob, regex, or mixed array of both, matching paths to only compile. Can also be an array of arrays containing
     * paths to explicitly match. When attempting to compile a non-matching file it's returned verbatim.
     */
    only?: string | RegExp | Array<string | RegExp> | void;

    /** Babylon parser options. */
    parserOpts?: BabylonOptions | void;

    /** List of plugins to load and use. */
    plugins?: Array<any> | void;

    /** List of presets (a set of plugins) to load and use. */
    presets?: Array<any> | void;

    /** Retain line numbers - will result in really ugly code. Default: `false` */
    retainLines?: boolean | void;

    /** Resolve a module source ie. import "SOURCE"; to a custom value. */
    +resolveModuleSource?: (source: string, filename: string) => string;

    /**
     * An optional callback that controls whether a comment should be output or not. Called as
     * `shouldPrintComment(commentContents)`. **NOTE**: This overrides the `comments` option when used.
     */
    shouldPrintComment?: (comment: string) => boolean;

    /** Set `sources[0]` on returned source map. */
    sourceFileName?: string | void;

    /**
     * If truthy, adds a `map` property to returned output. If set to `"inline"`, a comment with a `sourceMappingURL`
     * directive is added to the bottom of the returned code. If set to `"both"` then a map property is returned as well
     * as a source map comment appended.
     */
    sourceMaps?: boolean | 'inline' | 'both' | void;

    /** Set `file` on returned source map. */
    sourceMapTarget?: string | void;

    /** The root from which all sources are relative. */
    sourceRoot?: string | void;

    /** Indicate the mode the code should be parsed in. Can be either “script” or “module”. Default: "module" */
    sourceType?: 'script' | 'module' | void;

    /**
     * An optional callback that can be used to wrap visitor methods.
     * NOTE: This is useful for things like introspection, and not really needed for implementing anything.
     */
    +wrapPluginVisitorMethod?: (
      pluginAlias: string,
      visitorType: 'enter' | 'exit',
      // $FlowExpectedError(value-as-type)
      callback: (path: NodePath, state: any) => void
      // $FlowExpectedError(value-as-type)
    ) => (path: NodePath, state: any) => void;
  }

  declare export interface BabelFileModulesMetadata {
    imports: Array<Object>;
    exports: {
      exported: Array<Object>,
      specifiers: Array<Object>,
    };
  }

  declare export interface BabelFileMetadata {
    usedHelpers: Array<string>;
    marked: Array<{
      type: string,
      message: string,
      loc: { ... },
    }>;
    modules: BabelFileModulesMetadata;
  }

  declare export interface BabelFileResult {
    ast?: Node | void;
    code?: string | void;
    ignored?: boolean | void;
    map?: { ... } | void;
    metadata?: BabelFileMetadata | void;
  }

  declare export class __BabelFile {
    +opts: { [key: string]: any };
    // $FlowExpectedError(value-as-type)
    +declarations: { [key: string]: t.Identifier };
    // $FlowExpectedError(value-as-type)
    +path: NodePath<t.Program>;
    // $FlowExpectedError(value-as-type)
    +ast: t.File;
    // $FlowExpectedError(value-as-type)
    scope: Scope;
    metadata: { [key: string]: any };
    code: string;

    /**
     * Provide backward-compatible access to the interpreter directive handling
     * in Babel 6.x. If you are writing a plugin for Babel 7.x, it would be
     * best to use 'program.interpreter' directly.
     */
    inputMap: any;
    shebang: string;

    set(key: mixed, val: mixed): void;
    get(key: mixed): any;
    has(key: mixed): boolean;
    getModuleName(): ?string;

    /**
     * Check if a given helper is available in @babel/core's helper list.
     *
     * This _also_ allows you to pass a Babel version specifically. If the
     * helper exists, but was not available for the full given range, it will be
     * considered unavailable.
     */
    availableHelper(name: string, versionRange?: string | null): boolean;
    // $FlowExpectedError(value-as-type)
    addHelper(name: string): t.Identifier;

    buildCodeFrameError<CustomError: Error>(
      node: ?any,
      msg: string,
      _Error?: Class<CustomError>
    ): Error;
  }

  declare export class PluginPass {
    key: ?string;
    file: __BabelFile;
    opts: any;

    // The working directory that Babel's programmatic options are loaded
    // relative to.
    cwd: string;

    // The absolute path of the file being compiled.
    filename?: string;

    constructor(file: __BabelFile, key?: ?string, options?: any): this;

    set(key: mixed, val: mixed): void;
    get(key: mixed): any;

    availableHelper(name: string, versionRange?: string | null): boolean;

    // $FlowExpectedError(value-as-type)
    addHelper(name: string): t.Identifier;

    buildCodeFrameError<CustomError: Error = Error>(
      node: ?any,
      msg: string,
      _Error?: Class<CustomError>
    ): CustomError;
  }
}
